###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        15/Apr/2015  14:53:33
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\Dev_Tools\NordicSemi\nRF51-DK\nRF51_SDK_7.2.0_cf547b5\components\drivers_nrf\spi_master\spi_master.c
#    Command line =  
#        E:\Dev_Tools\NordicSemi\nRF51-DK\nRF51_SDK_7.2.0_cf547b5\components\drivers_nrf\spi_master\spi_master.c
#        -D NRF51 -D BOARD_PCA10028 -D BLE_STACK_SUPPORT_REQD -D S110 -D
#        SPI_MASTER_0_ENABLE -D ACCELEROMETER_ENABLE -lCN
#        E:\Professional\Nuzzle\Collar\FW\Proto_V1_Tests\examples\peripheral\spi_master\pca10028\Debug\List\
#        --diag_suppress Pe301,Pa082 -o
#        E:\Professional\Nuzzle\Collar\FW\Proto_V1_Tests\examples\peripheral\spi_master\pca10028\Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\Professional\Nuzzle\Collar\FW\Proto_V1_Tests\examples\peripheral\spi_master\pca10028\..\
#        -I
#        E:\Professional\Nuzzle\Collar\FW\Proto_V1_Tests\examples\peripheral\spi_master\pca10028\..\pca10028\
#        -I
#        E:\Professional\Nuzzle\Collar\FW\Proto_V1_Tests\examples\peripheral\spi_master\pca10028\..\devices\
#        -I
#        E:\Dev_Tools\NordicSemi\nRF51-DK\nRF51_SDK_7.2.0_cf547b5\components\drivers_nrf\hal\
#        -I
#        E:\Dev_Tools\NordicSemi\nRF51-DK\nRF51_SDK_7.2.0_cf547b5\components\drivers_nrf\spi_master\
#        -I
#        E:\Dev_Tools\NordicSemi\nRF51-DK\nRF51_SDK_7.2.0_cf547b5\components\libraries\gpiote\
#        -I
#        E:\Dev_Tools\NordicSemi\nRF51-DK\nRF51_SDK_7.2.0_cf547b5\components\libraries\scheduler\
#        -I
#        E:\Dev_Tools\NordicSemi\nRF51-DK\nRF51_SDK_7.2.0_cf547b5\components\libraries\timer\
#        -I
#        E:\Dev_Tools\NordicSemi\nRF51-DK\nRF51_SDK_7.2.0_cf547b5\components\libraries\util\
#        -I
#        E:\Dev_Tools\NordicSemi\nRF51-DK\nRF51_SDK_7.2.0_cf547b5\components\softdevice\s110\headers\
#        -I
#        E:\Dev_Tools\NordicSemi\nRF51-DK\nRF51_SDK_7.2.0_cf547b5\components\softdevice\common\softdevice_handler\
#        -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\" -On
#    List file    =  
#        E:\Professional\Nuzzle\Collar\FW\Proto_V1_Tests\examples\peripheral\spi_master\pca10028\Debug\List\spi_master.lst
#    Object file  =  
#        E:\Professional\Nuzzle\Collar\FW\Proto_V1_Tests\examples\peripheral\spi_master\pca10028\Debug\Obj\spi_master.o
#
###############################################################################

E:\Dev_Tools\NordicSemi\nRF51-DK\nRF51_SDK_7.2.0_cf547b5\components\drivers_nrf\spi_master\spi_master.c
      1          /* Copyright (c) 2014 Nordic Semiconductor. All Rights Reserved.
      2           *
      3           * The information contained herein is property of Nordic Semiconductor ASA.
      4           * Terms and conditions of usage are described in detail in NORDIC
      5           * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
      6           *
      7           * Licensees are granted free, non-transferable use of the information. NO
      8           * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
      9           * the file.
     10           *
     11           */
     12          
     13          #include "app_error.h"
     14          #include "nrf_gpio.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void nrf_gpio_cfg_output(uint32_t)
   \                     nrf_gpio_cfg_output: (+1)
   \   00000000   0x2103             MOVS     R1,#+3
   \   00000002   0x....             LDR      R2,??DataTable7  ;; 0x50000700
   \   00000004   0x2304             MOVS     R3,#+4
   \   00000006   0x4343             MULS     R3,R0,R3
   \   00000008   0x50D1             STR      R1,[R2, R3]
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void nrf_gpio_cfg_input(uint32_t, enum <unnamed>)
   \                     nrf_gpio_cfg_input: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xB2C9             UXTB     R1,R1
   \   00000004   0x008A             LSLS     R2,R1,#+2
   \   00000006   0x....             LDR      R3,??DataTable7  ;; 0x50000700
   \   00000008   0x2404             MOVS     R4,#+4
   \   0000000A   0x4344             MULS     R4,R0,R4
   \   0000000C   0x511A             STR      R2,[R3, R4]
   \   0000000E   0xBC10             POP      {R4}
   \   00000010   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void nrf_gpio_pin_set(uint32_t)
   \                     nrf_gpio_pin_set: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x4081             LSLS     R1,R1,R0
   \   00000004   0x....             LDR      R2,??DataTable8  ;; 0x50000508
   \   00000006   0x6011             STR      R1,[R2, #+0]
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void nrf_gpio_pin_clear(uint32_t)
   \                     nrf_gpio_pin_clear: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x4081             LSLS     R1,R1,R0
   \   00000004   0x....             LDR      R2,??DataTable8_1  ;; 0x5000050c
   \   00000006   0x6011             STR      R1,[R2, #+0]
   \   00000008   0x4770             BX       LR               ;; return
     15          #include "nrf_soc.h"
     16          #include "nrf51_bitfields.h"
     17          #include "spi_master.h"
     18          
     19          #if defined(SPI_MASTER_0_ENABLE) || defined(SPI_MASTER_1_ENABLE)
     20          
     21          typedef struct
     22          {
     23              NRF_SPI_Type * p_nrf_spi;   /**< A pointer to the NRF SPI master */
     24              IRQn_Type irq_type;         /**< A type of NVIC IRQn */
     25          
     26              uint8_t * p_tx_buffer;      /**< A pointer to TX buffer. */
     27              uint16_t tx_length;         /**< A length of TX buffer. */
     28              uint16_t tx_index;          /**< A index of the current element in the TX buffer. */
     29          
     30              uint8_t * p_rx_buffer;      /**< A pointer to RX buffer. */
     31              uint16_t rx_length;         /**< A length RX buffer. */
     32              uint16_t rx_index;          /**< A index of the current element in the RX buffer. */
     33          
     34              uint16_t max_length;        /**< Max length (Max of the TX and RX length). */
     35              uint16_t bytes_count;
     36              uint8_t pin_slave_select;   /**< A pin for Slave Select. */
     37          
     38              spi_master_event_handler_t callback_event_handler;  /**< A handler for event callback function. */
     39          
     40              spi_master_state_t state;   /**< A state of an instance of SPI master. */
     41              bool started_flag;
     42              bool disable_all_irq;
     43          
     44          } spi_master_instance_t;
     45          
     46          #define _static static
     47          

   \                                 In section .bss, align 4
     48          _static volatile spi_master_instance_t m_spi_master_instances[SPI_MASTER_HW_ENABLED_COUNT];
   \                     m_spi_master_instances:
   \   00000000                      DS8 40
     49          
     50          /* Function prototypes */
     51          static __INLINE volatile spi_master_instance_t * spi_master_get_instance(
     52              const spi_master_hw_instance_t spi_master_hw_instance);
     53          static __INLINE void spi_master_send_recv_irq(volatile spi_master_instance_t * const p_spi_instance);
     54          
     55          #endif //SPI_MASTER_0_ENABLE || SPI_MASTER_1_ENABLE
     56          
     57          #ifdef SPI_MASTER_0_ENABLE
     58          /**
     59           * @brief SPI0 interrupt handler.
     60           */

   \                                 In section .text, align 2, keep-with-next
     61          void SPI0_TWI0_IRQHandler(void)
     62          {
   \                     SPI0_TWI0_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     63              if ((NRF_SPI0->EVENTS_READY == 1) && (NRF_SPI0->INTENSET & SPI_INTENSET_READY_Msk))
   \   00000002   0x....             LDR      R0,??DataTable8_2  ;; 0x40003108
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD10D             BNE      ??SPI0_TWI0_IRQHandler_0
   \   0000000A   0x....             LDR      R0,??DataTable8_3  ;; 0x40003304
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x0740             LSLS     R0,R0,#+29
   \   00000010   0xD509             BPL      ??SPI0_TWI0_IRQHandler_0
     64              {
     65                  NRF_SPI0->EVENTS_READY = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x....             LDR      R1,??DataTable8_2  ;; 0x40003108
   \   00000016   0x6008             STR      R0,[R1, #+0]
     66          
     67                  volatile spi_master_instance_t * p_spi_instance = spi_master_get_instance(SPI_MASTER_0);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      BL       spi_master_get_instance
   \   0000001E   0x0004             MOVS     R4,R0
     68          
     69                  spi_master_send_recv_irq(p_spi_instance);
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       spi_master_send_recv_irq
     70              }
     71          }
   \                     ??SPI0_TWI0_IRQHandler_0: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
     72          #endif //SPI_MASTER_0_ENABLE
     73          
     74          #ifdef SPI_MASTER_1_ENABLE
     75          /**
     76           * @brief SPI0 interrupt handler.
     77           */
     78          void SPI1_TWI1_IRQHandler(void)
     79          {
     80              if ((NRF_SPI1->EVENTS_READY == 1) && (NRF_SPI1->INTENSET & SPI_INTENSET_READY_Msk))
     81              {
     82                  NRF_SPI1->EVENTS_READY = 0;
     83          
     84                  volatile spi_master_instance_t * p_spi_instance = spi_master_get_instance(SPI_MASTER_1);
     85          
     86                  spi_master_send_recv_irq(p_spi_instance);
     87              }
     88          }
     89          #endif //SPI_MASTER_1_ENABLE
     90          
     91          #if defined(SPI_MASTER_0_ENABLE) || defined(SPI_MASTER_1_ENABLE)
     92          /**
     93           * @breif Function for getting an instance of SPI master.
     94           */

   \                                 In section .text, align 2, keep-with-next
     95          static __INLINE volatile spi_master_instance_t * spi_master_get_instance(
     96              const spi_master_hw_instance_t spi_master_hw_instance)
     97          {
   \                     spi_master_get_instance: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0001             MOVS     R1,R0
     98              if (spi_master_hw_instance < SPI_MASTER_HW_ENABLED_COUNT)
   \   00000004   0xB2C9             UXTB     R1,R1
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD105             BNE      ??spi_master_get_instance_0
     99              {
    100                  return &(m_spi_master_instances[(uint8_t)spi_master_hw_instance]);
   \   0000000A   0x....             LDR      R0,??DataTable8_4
   \   0000000C   0xB2C9             UXTB     R1,R1
   \   0000000E   0x2228             MOVS     R2,#+40
   \   00000010   0x4351             MULS     R1,R2,R1
   \   00000012   0x1840             ADDS     R0,R0,R1
   \   00000014   0xE000             B        ??spi_master_get_instance_1
    101              }
    102              return NULL;
   \                     ??spi_master_get_instance_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \                     ??spi_master_get_instance_1: (+1)
   \   00000018   0xBD00             POP      {PC}             ;; return
    103          }
    104          
    105          /**
    106           * @brief Function for initializing instance of SPI master by default values.
    107           */

   \                                 In section .text, align 2, keep-with-next
    108          static __INLINE void spi_master_init_hw_instance(NRF_SPI_Type *                   p_nrf_spi,
    109                                                           IRQn_Type                        irq_type,
    110                                                           volatile spi_master_instance_t * p_spi_instance,
    111                                                           volatile bool                    disable_all_irq)
    112          {
   \                     spi_master_init_hw_instance: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0007             MOVS     R7,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0014             MOVS     R4,R2
    113              APP_ERROR_CHECK_BOOL(p_spi_instance != NULL);
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD001             BEQ      ??spi_master_init_hw_instance_0
   \   0000000C   0x2501             MOVS     R5,#+1
   \   0000000E   0xE000             B        ??spi_master_init_hw_instance_1
   \                     ??spi_master_init_hw_instance_0: (+1)
   \   00000010   0x2500             MOVS     R5,#+0
   \                     ??spi_master_init_hw_instance_1: (+1)
   \   00000012   0xB2ED             UXTB     R5,R5
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD104             BNE      ??spi_master_init_hw_instance_2
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      BL       app_error_handler
    114          
    115              p_spi_instance->p_nrf_spi = p_nrf_spi;
   \                     ??spi_master_init_hw_instance_2: (+1)
   \   00000022   0x6027             STR      R7,[R4, #+0]
    116              p_spi_instance->irq_type  = irq_type;
   \   00000024   0x7126             STRB     R6,[R4, #+4]
    117          
    118              p_spi_instance->p_tx_buffer = NULL;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x60A0             STR      R0,[R4, #+8]
    119              p_spi_instance->tx_length   = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x81A0             STRH     R0,[R4, #+12]
    120              p_spi_instance->tx_index    = 0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x81E0             STRH     R0,[R4, #+14]
    121          
    122              p_spi_instance->p_rx_buffer = NULL;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x6120             STR      R0,[R4, #+16]
    123              p_spi_instance->rx_length   = 0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x82A0             STRH     R0,[R4, #+20]
    124              p_spi_instance->rx_index    = 0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x82E0             STRH     R0,[R4, #+22]
    125          
    126              p_spi_instance->bytes_count      = 0;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x8360             STRH     R0,[R4, #+26]
    127              p_spi_instance->max_length       = 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x8320             STRH     R0,[R4, #+24]
    128              p_spi_instance->pin_slave_select = 0;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x7720             STRB     R0,[R4, #+28]
    129          
    130              p_spi_instance->callback_event_handler = NULL;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x6220             STR      R0,[R4, #+32]
    131          
    132              p_spi_instance->state           = SPI_MASTER_STATE_DISABLED;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x2124             MOVS     R1,#+36
   \   00000052   0x5460             STRB     R0,[R4, R1]
    133              p_spi_instance->started_flag    = false;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x2125             MOVS     R1,#+37
   \   00000058   0x5460             STRB     R0,[R4, R1]
    134              p_spi_instance->disable_all_irq = disable_all_irq;
   \   0000005A   0x4668             MOV      R0,SP
   \   0000005C   0x7800             LDRB     R0,[R0, #+0]
   \   0000005E   0x2126             MOVS     R1,#+38
   \   00000060   0x5460             STRB     R0,[R4, R1]
    135          }
   \   00000062   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    136          
    137          /**
    138           * @brief Function for initializing TX or RX buffer.
    139           */

   \                                 In section .text, align 2, keep-with-next
    140          static __INLINE void spi_master_buffer_init(uint8_t * const           p_buf,
    141                                                      const uint16_t            buf_len,
    142                                                      uint8_t * volatile *      pp_buf,
    143                                                      volatile uint16_t * const p_buf_len,
    144                                                      volatile uint16_t * const p_index)
    145          {
   \                     spi_master_buffer_init: (+1)
   \   00000000   0xB5FB             PUSH     {R0,R1,R3-R7,LR}
   \   00000002   0x0007             MOVS     R7,R0
   \   00000004   0x0016             MOVS     R6,R2
   \   00000006   0x9D08             LDR      R5,[SP, #+32]
    146              APP_ERROR_CHECK_BOOL(pp_buf != NULL);
   \   00000008   0x2E00             CMP      R6,#+0
   \   0000000A   0xD001             BEQ      ??spi_master_buffer_init_0
   \   0000000C   0x2401             MOVS     R4,#+1
   \   0000000E   0xE000             B        ??spi_master_buffer_init_1
   \                     ??spi_master_buffer_init_0: (+1)
   \   00000010   0x2400             MOVS     R4,#+0
   \                     ??spi_master_buffer_init_1: (+1)
   \   00000012   0xB2E4             UXTB     R4,R4
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD104             BNE      ??spi_master_buffer_init_2
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      BL       app_error_handler
    147              APP_ERROR_CHECK_BOOL(p_buf_len != NULL);
   \                     ??spi_master_buffer_init_2: (+1)
   \   00000022   0x9802             LDR      R0,[SP, #+8]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD001             BEQ      ??spi_master_buffer_init_3
   \   00000028   0x2401             MOVS     R4,#+1
   \   0000002A   0xE000             B        ??spi_master_buffer_init_4
   \                     ??spi_master_buffer_init_3: (+1)
   \   0000002C   0x2400             MOVS     R4,#+0
   \                     ??spi_master_buffer_init_4: (+1)
   \   0000002E   0xB2E4             UXTB     R4,R4
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD104             BNE      ??spi_master_buffer_init_5
   \   00000034   0x2200             MOVS     R2,#+0
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      BL       app_error_handler
    148              APP_ERROR_CHECK_BOOL(p_index != NULL);
   \                     ??spi_master_buffer_init_5: (+1)
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0xD001             BEQ      ??spi_master_buffer_init_6
   \   00000042   0x2401             MOVS     R4,#+1
   \   00000044   0xE000             B        ??spi_master_buffer_init_7
   \                     ??spi_master_buffer_init_6: (+1)
   \   00000046   0x2400             MOVS     R4,#+0
   \                     ??spi_master_buffer_init_7: (+1)
   \   00000048   0xB2E4             UXTB     R4,R4
   \   0000004A   0x2C00             CMP      R4,#+0
   \   0000004C   0xD104             BNE      ??spi_master_buffer_init_8
   \   0000004E   0x2200             MOVS     R2,#+0
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x.... 0x....      BL       app_error_handler
    149          
    150              *pp_buf    = p_buf;
   \                     ??spi_master_buffer_init_8: (+1)
   \   00000058   0x6037             STR      R7,[R6, #+0]
    151              *p_buf_len = (p_buf != NULL) ? buf_len : 0;
   \   0000005A   0x2F00             CMP      R7,#+0
   \   0000005C   0xD002             BEQ      ??spi_master_buffer_init_9
   \   0000005E   0x4668             MOV      R0,SP
   \   00000060   0x8880             LDRH     R0,[R0, #+4]
   \   00000062   0xE000             B        ??spi_master_buffer_init_10
   \                     ??spi_master_buffer_init_9: (+1)
   \   00000064   0x2000             MOVS     R0,#+0
   \                     ??spi_master_buffer_init_10: (+1)
   \   00000066   0x9902             LDR      R1,[SP, #+8]
   \   00000068   0x8008             STRH     R0,[R1, #+0]
    152              *p_index   = 0;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x8028             STRH     R0,[R5, #+0]
    153          }
   \   0000006E   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    154          
    155          /**
    156           * @brief Function for releasing TX or RX buffer.
    157           */

   \                                 In section .text, align 2, keep-with-next
    158          static __INLINE void spi_master_buffer_release(uint8_t * volatile * const pp_buf,
    159                                                         volatile uint16_t * const  p_buf_len)
    160          {
   \                     spi_master_buffer_release: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000D             MOVS     R5,R1
    161              APP_ERROR_CHECK_BOOL(pp_buf != NULL);
   \   00000006   0x2E00             CMP      R6,#+0
   \   00000008   0xD001             BEQ      ??spi_master_buffer_release_0
   \   0000000A   0x2401             MOVS     R4,#+1
   \   0000000C   0xE000             B        ??spi_master_buffer_release_1
   \                     ??spi_master_buffer_release_0: (+1)
   \   0000000E   0x2400             MOVS     R4,#+0
   \                     ??spi_master_buffer_release_1: (+1)
   \   00000010   0xB2E4             UXTB     R4,R4
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD104             BNE      ??spi_master_buffer_release_2
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      BL       app_error_handler
    162              APP_ERROR_CHECK_BOOL(p_buf_len != NULL);
   \                     ??spi_master_buffer_release_2: (+1)
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD001             BEQ      ??spi_master_buffer_release_3
   \   00000024   0x2401             MOVS     R4,#+1
   \   00000026   0xE000             B        ??spi_master_buffer_release_4
   \                     ??spi_master_buffer_release_3: (+1)
   \   00000028   0x2400             MOVS     R4,#+0
   \                     ??spi_master_buffer_release_4: (+1)
   \   0000002A   0xB2E4             UXTB     R4,R4
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD104             BNE      ??spi_master_buffer_release_5
   \   00000030   0x2200             MOVS     R2,#+0
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x.... 0x....      BL       app_error_handler
    163          
    164              *pp_buf    = NULL;
   \                     ??spi_master_buffer_release_5: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x6030             STR      R0,[R6, #+0]
    165              *p_buf_len = 0;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x8028             STRH     R0,[R5, #+0]
    166          }
   \   00000042   0xBD70             POP      {R4-R6,PC}       ;; return
    167          
    168          /**
    169           * @brief Function for sending events by callback.
    170           */

   \                                 In section .text, align 2, keep-with-next
    171          static __INLINE void spi_master_signal_evt(volatile spi_master_instance_t * const p_spi_instance,
    172                                                     spi_master_evt_type_t                  event_type,
    173                                                     const uint16_t                         data_count)
    174          {
   \                     spi_master_signal_evt: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0016             MOVS     R6,R2
    175              APP_ERROR_CHECK_BOOL(p_spi_instance != NULL);
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD001             BEQ      ??spi_master_signal_evt_0
   \   0000000C   0x2501             MOVS     R5,#+1
   \   0000000E   0xE000             B        ??spi_master_signal_evt_1
   \                     ??spi_master_signal_evt_0: (+1)
   \   00000010   0x2500             MOVS     R5,#+0
   \                     ??spi_master_signal_evt_1: (+1)
   \   00000012   0xB2ED             UXTB     R5,R5
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD104             BNE      ??spi_master_signal_evt_2
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      BL       app_error_handler
    176          
    177              if (p_spi_instance->callback_event_handler != NULL)
   \                     ??spi_master_signal_evt_2: (+1)
   \   00000022   0x6A20             LDR      R0,[R4, #+32]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD009             BEQ      ??spi_master_signal_evt_3
    178              {
    179                  spi_master_evt_t event = {SPI_MASTER_EVT_TYPE_MAX, 0};
   \   00000028   0x....             LDR      R0,??DataTable9
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x9000             STR      R0,[SP, #+0]
    180                  event.evt_type   = event_type;
   \   0000002E   0x4668             MOV      R0,SP
   \   00000030   0x7007             STRB     R7,[R0, #+0]
    181                  event.data_count = data_count;
   \   00000032   0x4668             MOV      R0,SP
   \   00000034   0x8046             STRH     R6,[R0, #+2]
    182                  p_spi_instance->callback_event_handler(event);
   \   00000036   0x9800             LDR      R0,[SP, #+0]
   \   00000038   0x6A21             LDR      R1,[R4, #+32]
   \   0000003A   0x4788             BLX      R1
    183              }
    184          }
   \                     ??spi_master_signal_evt_3: (+1)
   \   0000003C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    185          
    186          /**
    187           * @brief Function insert to a TX buffer another byte or two bytes (depends on flag @ref DOUBLE_BUFFERED).
    188           */

   \                                 In section .text, align 2, keep-with-next
    189          static __INLINE void spi_master_send_initial_bytes(
    190              volatile spi_master_instance_t * const p_spi_instance)
    191          {
   \                     spi_master_send_initial_bytes: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    192              APP_ERROR_CHECK_BOOL(p_spi_instance != NULL);
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD001             BEQ      ??spi_master_send_initial_bytes_0
   \   00000008   0x2501             MOVS     R5,#+1
   \   0000000A   0xE000             B        ??spi_master_send_initial_bytes_1
   \                     ??spi_master_send_initial_bytes_0: (+1)
   \   0000000C   0x2500             MOVS     R5,#+0
   \                     ??spi_master_send_initial_bytes_1: (+1)
   \   0000000E   0xB2ED             UXTB     R5,R5
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD104             BNE      ??spi_master_send_initial_bytes_2
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      BL       app_error_handler
    193          
    194              p_spi_instance->p_nrf_spi->TXD = ((p_spi_instance->p_tx_buffer != NULL) &&
    195                                                (p_spi_instance->tx_index < p_spi_instance->tx_length)) ?
    196                                               p_spi_instance->p_tx_buffer[p_spi_instance->tx_index] :
    197                                               SPI_DEFAULT_TX_BYTE;
   \                     ??spi_master_send_initial_bytes_2: (+1)
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x68A1             LDR      R1,[R4, #+8]
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xD008             BEQ      ??spi_master_send_initial_bytes_3
   \   00000026   0x89E1             LDRH     R1,[R4, #+14]
   \   00000028   0x89A2             LDRH     R2,[R4, #+12]
   \   0000002A   0xB289             UXTH     R1,R1
   \   0000002C   0x4291             CMP      R1,R2
   \   0000002E   0xD203             BCS      ??spi_master_send_initial_bytes_3
   \   00000030   0x68A1             LDR      R1,[R4, #+8]
   \   00000032   0x89E2             LDRH     R2,[R4, #+14]
   \   00000034   0x5C89             LDRB     R1,[R1, R2]
   \   00000036   0xE000             B        ??spi_master_send_initial_bytes_4
   \                     ??spi_master_send_initial_bytes_3: (+1)
   \   00000038   0x2100             MOVS     R1,#+0
   \                     ??spi_master_send_initial_bytes_4: (+1)
   \   0000003A   0x....             LDR      R2,??DataTable10  ;; 0x51c
   \   0000003C   0x5081             STR      R1,[R0, R2]
    198              (p_spi_instance->tx_index)++;
   \   0000003E   0x89E0             LDRH     R0,[R4, #+14]
   \   00000040   0x1C40             ADDS     R0,R0,#+1
   \   00000042   0x81E0             STRH     R0,[R4, #+14]
    199          
    200          
    201              if (p_spi_instance->tx_index < p_spi_instance->max_length)
   \   00000044   0x89E0             LDRH     R0,[R4, #+14]
   \   00000046   0x8B21             LDRH     R1,[R4, #+24]
   \   00000048   0xB280             UXTH     R0,R0
   \   0000004A   0x4288             CMP      R0,R1
   \   0000004C   0xD212             BCS      ??spi_master_send_initial_bytes_5
    202              {
    203                  p_spi_instance->p_nrf_spi->TXD = ((p_spi_instance->p_tx_buffer != NULL) &&
    204                                                    (p_spi_instance->tx_index < p_spi_instance->tx_length)) ?
    205                                                   p_spi_instance->p_tx_buffer[p_spi_instance->tx_index] :
    206                                                   SPI_DEFAULT_TX_BYTE;
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x68A1             LDR      R1,[R4, #+8]
   \   00000052   0x2900             CMP      R1,#+0
   \   00000054   0xD008             BEQ      ??spi_master_send_initial_bytes_6
   \   00000056   0x89E1             LDRH     R1,[R4, #+14]
   \   00000058   0x89A2             LDRH     R2,[R4, #+12]
   \   0000005A   0xB289             UXTH     R1,R1
   \   0000005C   0x4291             CMP      R1,R2
   \   0000005E   0xD203             BCS      ??spi_master_send_initial_bytes_6
   \   00000060   0x68A1             LDR      R1,[R4, #+8]
   \   00000062   0x89E2             LDRH     R2,[R4, #+14]
   \   00000064   0x5C89             LDRB     R1,[R1, R2]
   \   00000066   0xE000             B        ??spi_master_send_initial_bytes_7
   \                     ??spi_master_send_initial_bytes_6: (+1)
   \   00000068   0x2100             MOVS     R1,#+0
   \                     ??spi_master_send_initial_bytes_7: (+1)
   \   0000006A   0x....             LDR      R2,??DataTable10  ;; 0x51c
   \   0000006C   0x5081             STR      R1,[R0, R2]
    207                  (p_spi_instance->tx_index)++;
   \   0000006E   0x89E0             LDRH     R0,[R4, #+14]
   \   00000070   0x1C40             ADDS     R0,R0,#+1
   \   00000072   0x81E0             STRH     R0,[R4, #+14]
    208              }
    209          }
   \                     ??spi_master_send_initial_bytes_5: (+1)
   \   00000074   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    210          
    211          /**
    212           * @brief Function for receiving and sending data from IRQ. (The same for both IRQs).
    213           */

   \                                 In section .text, align 2, keep-with-next
    214          static __INLINE void spi_master_send_recv_irq(volatile spi_master_instance_t * const p_spi_instance)
    215          {
   \                     spi_master_send_recv_irq: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    216              APP_ERROR_CHECK_BOOL(p_spi_instance != NULL);
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD001             BEQ      ??spi_master_send_recv_irq_0
   \   00000008   0x2501             MOVS     R5,#+1
   \   0000000A   0xE000             B        ??spi_master_send_recv_irq_1
   \                     ??spi_master_send_recv_irq_0: (+1)
   \   0000000C   0x2500             MOVS     R5,#+0
   \                     ??spi_master_send_recv_irq_1: (+1)
   \   0000000E   0xB2ED             UXTB     R5,R5
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD104             BNE      ??spi_master_send_recv_irq_2
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      BL       app_error_handler
    217          
    218              p_spi_instance->bytes_count++;
   \                     ??spi_master_send_recv_irq_2: (+1)
   \   0000001E   0x8B60             LDRH     R0,[R4, #+26]
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0x8360             STRH     R0,[R4, #+26]
    219          
    220              if (!p_spi_instance->started_flag)
   \   00000024   0x2025             MOVS     R0,#+37
   \   00000026   0x5C20             LDRB     R0,[R4, R0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD107             BNE      ??spi_master_send_recv_irq_3
    221              {
    222                  p_spi_instance->started_flag = true;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x2125             MOVS     R1,#+37
   \   00000030   0x5460             STRB     R0,[R4, R1]
    223                  spi_master_signal_evt(p_spi_instance,
    224                                        SPI_MASTER_EVT_TRANSFER_STARTED,
    225                                        p_spi_instance->bytes_count);
   \   00000032   0x8B62             LDRH     R2,[R4, #+26]
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       spi_master_signal_evt
    226              }
    227          
    228              uint8_t rx_byte = p_spi_instance->p_nrf_spi->RXD;
   \                     ??spi_master_send_recv_irq_3: (+1)
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x21A3             MOVS     R1,#+163
   \   00000040   0x00C9             LSLS     R1,R1,#+3        ;; #+1304
   \   00000042   0x5846             LDR      R6,[R0, R1]
    229          
    230              if ((p_spi_instance->p_rx_buffer != NULL) &&
    231                  (p_spi_instance->rx_index < p_spi_instance->rx_length))
   \   00000044   0x6920             LDR      R0,[R4, #+16]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD00B             BEQ      ??spi_master_send_recv_irq_4
   \   0000004A   0x8AE0             LDRH     R0,[R4, #+22]
   \   0000004C   0x8AA1             LDRH     R1,[R4, #+20]
   \   0000004E   0xB280             UXTH     R0,R0
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD206             BCS      ??spi_master_send_recv_irq_4
    232              {
    233                  p_spi_instance->p_rx_buffer[p_spi_instance->rx_index++] = rx_byte;
   \   00000054   0x6920             LDR      R0,[R4, #+16]
   \   00000056   0x8AE1             LDRH     R1,[R4, #+22]
   \   00000058   0x000A             MOVS     R2,R1
   \   0000005A   0x1C52             ADDS     R2,R2,#+1
   \   0000005C   0x82E2             STRH     R2,[R4, #+22]
   \   0000005E   0xB289             UXTH     R1,R1
   \   00000060   0x5446             STRB     R6,[R0, R1]
    234              }
    235          
    236              if (p_spi_instance->tx_index < p_spi_instance->max_length)
   \                     ??spi_master_send_recv_irq_4: (+1)
   \   00000062   0x89E0             LDRH     R0,[R4, #+14]
   \   00000064   0x8B21             LDRH     R1,[R4, #+24]
   \   00000066   0xB280             UXTH     R0,R0
   \   00000068   0x4288             CMP      R0,R1
   \   0000006A   0xD212             BCS      ??spi_master_send_recv_irq_5
    237              {
    238                  p_spi_instance->p_nrf_spi->TXD = ((p_spi_instance->p_tx_buffer != NULL) &&
    239                                                    (p_spi_instance->tx_index < p_spi_instance->tx_length)) ?
    240                                                   p_spi_instance->p_tx_buffer[p_spi_instance->tx_index] :
    241                                                   SPI_DEFAULT_TX_BYTE;
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x68A1             LDR      R1,[R4, #+8]
   \   00000070   0x2900             CMP      R1,#+0
   \   00000072   0xD008             BEQ      ??spi_master_send_recv_irq_6
   \   00000074   0x89E1             LDRH     R1,[R4, #+14]
   \   00000076   0x89A2             LDRH     R2,[R4, #+12]
   \   00000078   0xB289             UXTH     R1,R1
   \   0000007A   0x4291             CMP      R1,R2
   \   0000007C   0xD203             BCS      ??spi_master_send_recv_irq_6
   \   0000007E   0x68A1             LDR      R1,[R4, #+8]
   \   00000080   0x89E2             LDRH     R2,[R4, #+14]
   \   00000082   0x5C89             LDRB     R1,[R1, R2]
   \   00000084   0xE000             B        ??spi_master_send_recv_irq_7
   \                     ??spi_master_send_recv_irq_6: (+1)
   \   00000086   0x2100             MOVS     R1,#+0
   \                     ??spi_master_send_recv_irq_7: (+1)
   \   00000088   0x....             LDR      R2,??DataTable10  ;; 0x51c
   \   0000008A   0x5081             STR      R1,[R0, R2]
    242                  (p_spi_instance->tx_index)++;
   \   0000008C   0x89E0             LDRH     R0,[R4, #+14]
   \   0000008E   0x1C40             ADDS     R0,R0,#+1
   \   00000090   0x81E0             STRH     R0,[R4, #+14]
    243              }
    244          
    245              if (p_spi_instance->bytes_count >= p_spi_instance->max_length)
   \                     ??spi_master_send_recv_irq_5: (+1)
   \   00000092   0x8B60             LDRH     R0,[R4, #+26]
   \   00000094   0x8B21             LDRH     R1,[R4, #+24]
   \   00000096   0xB280             UXTH     R0,R0
   \   00000098   0x4288             CMP      R0,R1
   \   0000009A   0xD318             BCC      ??spi_master_send_recv_irq_8
    246              {
    247                  nrf_gpio_pin_set(p_spi_instance->pin_slave_select);
   \   0000009C   0x7F20             LDRB     R0,[R4, #+28]
   \   0000009E   0x.... 0x....      BL       nrf_gpio_pin_set
    248          
    249                  uint16_t transmited_bytes = p_spi_instance->tx_index;
   \   000000A2   0x89E5             LDRH     R5,[R4, #+14]
    250          
    251                  spi_master_buffer_release(&(p_spi_instance->p_tx_buffer), &(p_spi_instance->tx_length));
   \   000000A4   0x0021             MOVS     R1,R4
   \   000000A6   0x310C             ADDS     R1,R1,#+12
   \   000000A8   0x0020             MOVS     R0,R4
   \   000000AA   0x3008             ADDS     R0,R0,#+8
   \   000000AC   0x.... 0x....      BL       spi_master_buffer_release
    252                  spi_master_buffer_release(&(p_spi_instance->p_rx_buffer), &(p_spi_instance->rx_length));
   \   000000B0   0x0021             MOVS     R1,R4
   \   000000B2   0x3114             ADDS     R1,R1,#+20
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0x3010             ADDS     R0,R0,#+16
   \   000000B8   0x.... 0x....      BL       spi_master_buffer_release
    253          
    254                  p_spi_instance->state = SPI_MASTER_STATE_IDLE;
   \   000000BC   0x2002             MOVS     R0,#+2
   \   000000BE   0x2124             MOVS     R1,#+36
   \   000000C0   0x5460             STRB     R0,[R4, R1]
    255          
    256                  spi_master_signal_evt(p_spi_instance, SPI_MASTER_EVT_TRANSFER_COMPLETED, transmited_bytes);
   \   000000C2   0x002A             MOVS     R2,R5
   \   000000C4   0xB292             UXTH     R2,R2
   \   000000C6   0x2101             MOVS     R1,#+1
   \   000000C8   0x0020             MOVS     R0,R4
   \   000000CA   0x.... 0x....      BL       spi_master_signal_evt
    257          
    258              }
    259          }
   \                     ??spi_master_send_recv_irq_8: (+1)
   \   000000CE   0xBD70             POP      {R4-R6,PC}       ;; return
    260          #endif //defined(SPI_MASTER_0_ENABLE) || defined(SPI_MASTER_1_ENABLE)

   \                                 In section .text, align 2, keep-with-next
    261          uint32_t spi_master_open(const spi_master_hw_instance_t    spi_master_hw_instance,
    262                                   spi_master_config_t const * const p_spi_master_config)
    263          {
   \                     spi_master_open: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0007             MOVS     R7,R0
   \   00000004   0x000C             MOVS     R4,R1
    264              #if defined(SPI_MASTER_0_ENABLE) || defined(SPI_MASTER_1_ENABLE)
    265          
    266              /* Check against null */
    267              if (p_spi_master_config == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE      ??spi_master_open_0
    268              {
    269                  return NRF_ERROR_NULL;
   \   0000000A   0x200E             MOVS     R0,#+14
   \   0000000C   0xE08A             B        ??spi_master_open_1
    270              }
    271          
    272              volatile spi_master_instance_t * p_spi_instance = spi_master_get_instance(
    273                  spi_master_hw_instance);
   \                     ??spi_master_open_0: (+1)
   \   0000000E   0x0038             MOVS     R0,R7
   \   00000010   0xB2C0             UXTB     R0,R0
   \   00000012   0x.... 0x....      BL       spi_master_get_instance
   \   00000016   0x0005             MOVS     R5,R0
    274              APP_ERROR_CHECK_BOOL(p_spi_instance != NULL);
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD001             BEQ      ??spi_master_open_2
   \   0000001C   0x2601             MOVS     R6,#+1
   \   0000001E   0xE000             B        ??spi_master_open_3
   \                     ??spi_master_open_2: (+1)
   \   00000020   0x2600             MOVS     R6,#+0
   \                     ??spi_master_open_3: (+1)
   \   00000022   0xB2F6             UXTB     R6,R6
   \   00000024   0x2E00             CMP      R6,#+0
   \   00000026   0xD104             BNE      ??spi_master_open_4
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x.... 0x....      BL       app_error_handler
    275          
    276              switch (spi_master_hw_instance)
   \                     ??spi_master_open_4: (+1)
   \   00000032   0xB2FF             UXTB     R7,R7
   \   00000034   0x2F00             CMP      R7,#+0
   \   00000036   0xD10C             BNE      ??spi_master_open_5
    277              {
    278              #ifdef SPI_MASTER_0_ENABLE
    279                  case SPI_MASTER_0:
    280                      spi_master_init_hw_instance(NRF_SPI0, SPI0_TWI0_IRQn, p_spi_instance, p_spi_master_config->SPI_DisableAllIRQ);
   \   00000038   0x7EE0             LDRB     R0,[R4, #+27]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD001             BEQ      ??spi_master_open_6
   \   0000003E   0x2301             MOVS     R3,#+1
   \   00000040   0xE000             B        ??spi_master_open_7
   \                     ??spi_master_open_6: (+1)
   \   00000042   0x2300             MOVS     R3,#+0
   \                     ??spi_master_open_7: (+1)
   \   00000044   0xB2DB             UXTB     R3,R3
   \   00000046   0x002A             MOVS     R2,R5
   \   00000048   0x2103             MOVS     R1,#+3
   \   0000004A   0x....             LDR      R0,??DataTable10_1  ;; 0x40003000
   \   0000004C   0x.... 0x....      BL       spi_master_init_hw_instance
    281                      break;
   \   00000050   0xE7FF             B        ??spi_master_open_8
    282              #endif /* SPI_MASTER_0_ENABLE */
    283          
    284              #ifdef SPI_MASTER_1_ENABLE
    285                  case SPI_MASTER_1:
    286                      spi_master_init_hw_instance(NRF_SPI1, SPI1_TWI1_IRQn, p_spi_instance, p_spi_master_config->SPI_DisableAllIRQ);
    287                      break;
    288              #endif /* SPI_MASTER_1_ENABLE */
    289          
    290                  default:
    291                      break;
    292              }
    293          
    294              //A Slave select must be set as high before setting it as output,
    295              //because during connect it to the pin it causes glitches.
    296              nrf_gpio_pin_set(p_spi_master_config->SPI_Pin_SS);
   \                     ??spi_master_open_5: (+1)
   \                     ??spi_master_open_8: (+1)
   \   00000052   0x6920             LDR      R0,[R4, #+16]
   \   00000054   0x.... 0x....      BL       nrf_gpio_pin_set
    297              nrf_gpio_cfg_output(p_spi_master_config->SPI_Pin_SS);
   \   00000058   0x6920             LDR      R0,[R4, #+16]
   \   0000005A   0x.... 0x....      BL       nrf_gpio_cfg_output
    298              nrf_gpio_pin_set(p_spi_master_config->SPI_Pin_SS);
   \   0000005E   0x6920             LDR      R0,[R4, #+16]
   \   00000060   0x.... 0x....      BL       nrf_gpio_pin_set
    299          
    300              //Configure GPIO
    301              nrf_gpio_cfg_output(p_spi_master_config->SPI_Pin_SCK);
   \   00000064   0x6860             LDR      R0,[R4, #+4]
   \   00000066   0x.... 0x....      BL       nrf_gpio_cfg_output
    302              nrf_gpio_cfg_output(p_spi_master_config->SPI_Pin_MOSI);
   \   0000006A   0x68E0             LDR      R0,[R4, #+12]
   \   0000006C   0x.... 0x....      BL       nrf_gpio_cfg_output
    303              nrf_gpio_cfg_input(p_spi_master_config->SPI_Pin_MISO, NRF_GPIO_PIN_NOPULL);
   \   00000070   0x2100             MOVS     R1,#+0
   \   00000072   0x68A0             LDR      R0,[R4, #+8]
   \   00000074   0x.... 0x....      BL       nrf_gpio_cfg_input
    304              p_spi_instance->pin_slave_select = p_spi_master_config->SPI_Pin_SS;
   \   00000078   0x6920             LDR      R0,[R4, #+16]
   \   0000007A   0x7728             STRB     R0,[R5, #+28]
    305          
    306              /* Configure SPI hardware */
    307              p_spi_instance->p_nrf_spi->PSELSCK  = p_spi_master_config->SPI_Pin_SCK;
   \   0000007C   0x6860             LDR      R0,[R4, #+4]
   \   0000007E   0x6829             LDR      R1,[R5, #+0]
   \   00000080   0x22A1             MOVS     R2,#+161
   \   00000082   0x00D2             LSLS     R2,R2,#+3        ;; #+1288
   \   00000084   0x5088             STR      R0,[R1, R2]
    308              p_spi_instance->p_nrf_spi->PSELMOSI = p_spi_master_config->SPI_Pin_MOSI;
   \   00000086   0x68E0             LDR      R0,[R4, #+12]
   \   00000088   0x6829             LDR      R1,[R5, #+0]
   \   0000008A   0x....             LDR      R2,??DataTable10_2  ;; 0x50c
   \   0000008C   0x5088             STR      R0,[R1, R2]
    309              p_spi_instance->p_nrf_spi->PSELMISO = p_spi_master_config->SPI_Pin_MISO;
   \   0000008E   0x68A0             LDR      R0,[R4, #+8]
   \   00000090   0x6829             LDR      R1,[R5, #+0]
   \   00000092   0x22A2             MOVS     R2,#+162
   \   00000094   0x00D2             LSLS     R2,R2,#+3        ;; #+1296
   \   00000096   0x5088             STR      R0,[R1, R2]
    310          
    311              p_spi_instance->p_nrf_spi->FREQUENCY = p_spi_master_config->SPI_Freq;
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x6829             LDR      R1,[R5, #+0]
   \   0000009C   0x....             LDR      R2,??DataTable10_3  ;; 0x524
   \   0000009E   0x5088             STR      R0,[R1, R2]
    312          
    313              p_spi_instance->p_nrf_spi->CONFIG =
    314                  (uint32_t)(p_spi_master_config->SPI_CONFIG_CPHA << SPI_CONFIG_CPHA_Pos) |
    315                  (p_spi_master_config->SPI_CONFIG_CPOL << SPI_CONFIG_CPOL_Pos) |
    316                  (p_spi_master_config->SPI_CONFIG_ORDER << SPI_CONFIG_ORDER_Pos);
   \   000000A0   0x7EA0             LDRB     R0,[R4, #+26]
   \   000000A2   0x0040             LSLS     R0,R0,#+1
   \   000000A4   0x7E61             LDRB     R1,[R4, #+25]
   \   000000A6   0x0089             LSLS     R1,R1,#+2
   \   000000A8   0x4301             ORRS     R1,R1,R0
   \   000000AA   0x7E20             LDRB     R0,[R4, #+24]
   \   000000AC   0x4308             ORRS     R0,R0,R1
   \   000000AE   0x6829             LDR      R1,[R5, #+0]
   \   000000B0   0x....             LDR      R2,??DataTable10_4  ;; 0x554
   \   000000B2   0x5088             STR      R0,[R1, R2]
    317          
    318              /* Clear waiting interrupts and events */
    319              p_spi_instance->p_nrf_spi->EVENTS_READY = 0;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x6829             LDR      R1,[R5, #+0]
   \   000000B8   0x2284             MOVS     R2,#+132
   \   000000BA   0x0052             LSLS     R2,R2,#+1        ;; #+264
   \   000000BC   0x5088             STR      R0,[R1, R2]
    320          
    321              APP_ERROR_CHECK(sd_nvic_ClearPendingIRQ(p_spi_instance->irq_type));
   \   000000BE   0x2004             MOVS     R0,#+4
   \   000000C0   0x5628             LDRSB    R0,[R5, R0]
   \   000000C2   0xDF2A             SVC      0x2A
   \   000000C4   0x0006             MOVS     R6,R0
   \   000000C6   0x2E00             CMP      R6,#+0
   \   000000C8   0xD004             BEQ      ??spi_master_open_9
   \   000000CA   0x2200             MOVS     R2,#+0
   \   000000CC   0x2100             MOVS     R1,#+0
   \   000000CE   0x0030             MOVS     R0,R6
   \   000000D0   0x.... 0x....      BL       app_error_handler
    322              APP_ERROR_CHECK(sd_nvic_SetPriority(p_spi_instance->irq_type, p_spi_master_config->SPI_PriorityIRQ));
   \                     ??spi_master_open_9: (+1)
   \   000000D4   0x6961             LDR      R1,[R4, #+20]
   \   000000D6   0xB2C9             UXTB     R1,R1
   \   000000D8   0x2004             MOVS     R0,#+4
   \   000000DA   0x5628             LDRSB    R0,[R5, R0]
   \   000000DC   0xDF2B             SVC      0x2B
   \   000000DE   0x0006             MOVS     R6,R0
   \   000000E0   0x2E00             CMP      R6,#+0
   \   000000E2   0xD004             BEQ      ??spi_master_open_10
   \   000000E4   0x2200             MOVS     R2,#+0
   \   000000E6   0x2100             MOVS     R1,#+0
   \   000000E8   0x0030             MOVS     R0,R6
   \   000000EA   0x.... 0x....      BL       app_error_handler
    323          
    324              /* Clear event handler */
    325              p_spi_instance->callback_event_handler = NULL;
   \                     ??spi_master_open_10: (+1)
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x6228             STR      R0,[R5, #+32]
    326          
    327              /* Enable interrupt */
    328              p_spi_instance->p_nrf_spi->INTENSET = (SPI_INTENSET_READY_Set << SPI_INTENCLR_READY_Pos);
   \   000000F2   0x2004             MOVS     R0,#+4
   \   000000F4   0x6829             LDR      R1,[R5, #+0]
   \   000000F6   0x22C1             MOVS     R2,#+193
   \   000000F8   0x0092             LSLS     R2,R2,#+2        ;; #+772
   \   000000FA   0x5088             STR      R0,[R1, R2]
    329              APP_ERROR_CHECK(sd_nvic_EnableIRQ(p_spi_instance->irq_type));
   \   000000FC   0x2004             MOVS     R0,#+4
   \   000000FE   0x5628             LDRSB    R0,[R5, R0]
   \   00000100   0xDF26             SVC      0x26
   \   00000102   0x0006             MOVS     R6,R0
   \   00000104   0x2E00             CMP      R6,#+0
   \   00000106   0xD004             BEQ      ??spi_master_open_11
   \   00000108   0x2200             MOVS     R2,#+0
   \   0000010A   0x2100             MOVS     R1,#+0
   \   0000010C   0x0030             MOVS     R0,R6
   \   0000010E   0x.... 0x....      BL       app_error_handler
    330          
    331              /* Enable SPI hardware */
    332              p_spi_instance->p_nrf_spi->ENABLE = (SPI_ENABLE_ENABLE_Enabled << SPI_ENABLE_ENABLE_Pos);
   \                     ??spi_master_open_11: (+1)
   \   00000112   0x2001             MOVS     R0,#+1
   \   00000114   0x6829             LDR      R1,[R5, #+0]
   \   00000116   0x22A0             MOVS     R2,#+160
   \   00000118   0x00D2             LSLS     R2,R2,#+3        ;; #+1280
   \   0000011A   0x5088             STR      R0,[R1, R2]
    333          
    334              /* Change state to IDLE */
    335              p_spi_instance->state = SPI_MASTER_STATE_IDLE;
   \   0000011C   0x2002             MOVS     R0,#+2
   \   0000011E   0x2124             MOVS     R1,#+36
   \   00000120   0x5468             STRB     R0,[R5, R1]
    336          
    337              return NRF_SUCCESS;
   \   00000122   0x2000             MOVS     R0,#+0
   \                     ??spi_master_open_1: (+1)
   \   00000124   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    338              #else
    339              return NRF_ERROR_NOT_SUPPORTED;
    340              #endif
    341          }
    342          

   \                                 In section .text, align 2, keep-with-next
    343          void spi_master_close(const spi_master_hw_instance_t spi_master_hw_instance)
    344          {
   \                     spi_master_close: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
    345              #if defined(SPI_MASTER_0_ENABLE) || defined(SPI_MASTER_1_ENABLE)
    346          
    347              volatile spi_master_instance_t * p_spi_instance = spi_master_get_instance(
    348                  spi_master_hw_instance);
   \   00000004   0x0030             MOVS     R0,R6
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x.... 0x....      BL       spi_master_get_instance
   \   0000000C   0x0004             MOVS     R4,R0
    349              APP_ERROR_CHECK_BOOL(p_spi_instance != NULL);
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD001             BEQ      ??spi_master_close_0
   \   00000012   0x2501             MOVS     R5,#+1
   \   00000014   0xE000             B        ??spi_master_close_1
   \                     ??spi_master_close_0: (+1)
   \   00000016   0x2500             MOVS     R5,#+0
   \                     ??spi_master_close_1: (+1)
   \   00000018   0xB2ED             UXTB     R5,R5
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD104             BNE      ??spi_master_close_2
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      BL       app_error_handler
    350          
    351              /* Disable interrupt */
    352              APP_ERROR_CHECK(sd_nvic_ClearPendingIRQ(p_spi_instance->irq_type));
   \                     ??spi_master_close_2: (+1)
   \   00000028   0x2004             MOVS     R0,#+4
   \   0000002A   0x5620             LDRSB    R0,[R4, R0]
   \   0000002C   0xDF2A             SVC      0x2A
   \   0000002E   0x0005             MOVS     R5,R0
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD004             BEQ      ??spi_master_close_3
   \   00000034   0x2200             MOVS     R2,#+0
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x0028             MOVS     R0,R5
   \   0000003A   0x.... 0x....      BL       app_error_handler
    353              APP_ERROR_CHECK(sd_nvic_DisableIRQ(p_spi_instance->irq_type));
   \                     ??spi_master_close_3: (+1)
   \   0000003E   0x2004             MOVS     R0,#+4
   \   00000040   0x5620             LDRSB    R0,[R4, R0]
   \   00000042   0xDF27             SVC      0x27
   \   00000044   0x0005             MOVS     R5,R0
   \   00000046   0x2D00             CMP      R5,#+0
   \   00000048   0xD004             BEQ      ??spi_master_close_4
   \   0000004A   0x2200             MOVS     R2,#+0
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x0028             MOVS     R0,R5
   \   00000050   0x.... 0x....      BL       app_error_handler
    354          
    355              p_spi_instance->p_nrf_spi->ENABLE = (SPI_ENABLE_ENABLE_Disabled << SPI_ENABLE_ENABLE_Pos);
   \                     ??spi_master_close_4: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x6821             LDR      R1,[R4, #+0]
   \   00000058   0x22A0             MOVS     R2,#+160
   \   0000005A   0x00D2             LSLS     R2,R2,#+3        ;; #+1280
   \   0000005C   0x5088             STR      R0,[R1, R2]
    356          
    357              /* Set Slave Select pin as input with pull-up. */
    358              nrf_gpio_pin_set(p_spi_instance->pin_slave_select);
   \   0000005E   0x7F20             LDRB     R0,[R4, #+28]
   \   00000060   0x.... 0x....      BL       nrf_gpio_pin_set
    359              nrf_gpio_cfg_input(p_spi_instance->pin_slave_select, NRF_GPIO_PIN_PULLUP);
   \   00000064   0x2103             MOVS     R1,#+3
   \   00000066   0x7F20             LDRB     R0,[R4, #+28]
   \   00000068   0x.... 0x....      BL       nrf_gpio_cfg_input
    360              p_spi_instance->pin_slave_select = (uint8_t)0xFF;
   \   0000006C   0x20FF             MOVS     R0,#+255
   \   0000006E   0x7720             STRB     R0,[R4, #+28]
    361          
    362              /* Disconnect pins from SPI hardware */
    363              p_spi_instance->p_nrf_spi->PSELSCK  = (uint32_t)SPI_PIN_DISCONNECTED;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000074   0x6821             LDR      R1,[R4, #+0]
   \   00000076   0x22A1             MOVS     R2,#+161
   \   00000078   0x00D2             LSLS     R2,R2,#+3        ;; #+1288
   \   0000007A   0x5088             STR      R0,[R1, R2]
    364              p_spi_instance->p_nrf_spi->PSELMOSI = (uint32_t)SPI_PIN_DISCONNECTED;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000080   0x6821             LDR      R1,[R4, #+0]
   \   00000082   0x....             LDR      R2,??DataTable10_2  ;; 0x50c
   \   00000084   0x5088             STR      R0,[R1, R2]
    365              p_spi_instance->p_nrf_spi->PSELMISO = (uint32_t)SPI_PIN_DISCONNECTED;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x43C0             MVNS     R0,R0            ;; #-1
   \   0000008A   0x6821             LDR      R1,[R4, #+0]
   \   0000008C   0x22A2             MOVS     R2,#+162
   \   0000008E   0x00D2             LSLS     R2,R2,#+3        ;; #+1296
   \   00000090   0x5088             STR      R0,[R1, R2]
    366          
    367              /* Reset to default values */
    368              spi_master_init_hw_instance(NULL, (IRQn_Type)0, p_spi_instance, false);
   \   00000092   0x2300             MOVS     R3,#+0
   \   00000094   0x0022             MOVS     R2,R4
   \   00000096   0x2100             MOVS     R1,#+0
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x.... 0x....      BL       spi_master_init_hw_instance
    369              #else
    370              return;
    371              #endif
    372          }
   \   0000009E   0xBD70             POP      {R4-R6,PC}       ;; return
    373          

   \                                 In section .text, align 2, keep-with-next
    374          __INLINE spi_master_state_t spi_master_get_state(
    375              const spi_master_hw_instance_t spi_master_hw_instance)
    376          {
   \                     spi_master_get_state: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
    377              #if defined(SPI_MASTER_0_ENABLE) || defined(SPI_MASTER_1_ENABLE)
    378              volatile spi_master_instance_t * p_spi_instance = spi_master_get_instance(
    379                  spi_master_hw_instance);
   \   00000004   0x0030             MOVS     R0,R6
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x.... 0x....      BL       spi_master_get_instance
   \   0000000C   0x0004             MOVS     R4,R0
    380              APP_ERROR_CHECK_BOOL(p_spi_instance != NULL);
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD001             BEQ      ??spi_master_get_state_0
   \   00000012   0x2501             MOVS     R5,#+1
   \   00000014   0xE000             B        ??spi_master_get_state_1
   \                     ??spi_master_get_state_0: (+1)
   \   00000016   0x2500             MOVS     R5,#+0
   \                     ??spi_master_get_state_1: (+1)
   \   00000018   0xB2ED             UXTB     R5,R5
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD104             BNE      ??spi_master_get_state_2
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      BL       app_error_handler
    381          
    382              return p_spi_instance->state;
   \                     ??spi_master_get_state_2: (+1)
   \   00000028   0x3424             ADDS     R4,R4,#+36
   \   0000002A   0x7820             LDRB     R0,[R4, #+0]
   \   0000002C   0xBD70             POP      {R4-R6,PC}       ;; return
    383              #else
    384              return SPI_MASTER_STATE_DISABLED;
    385              #endif
    386          }
    387          

   \                                 In section .text, align 2, keep-with-next
    388          __INLINE void spi_master_evt_handler_reg(const spi_master_hw_instance_t spi_master_hw_instance,
    389                                                   spi_master_event_handler_t     event_handler)
    390          {
   \                     spi_master_evt_handler_reg: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0007             MOVS     R7,R0
   \   00000004   0x000E             MOVS     R6,R1
    391              #if defined(SPI_MASTER_0_ENABLE) || defined(SPI_MASTER_1_ENABLE)
    392              volatile spi_master_instance_t * p_spi_instance = spi_master_get_instance(
    393                  spi_master_hw_instance);
   \   00000006   0x0038             MOVS     R0,R7
   \   00000008   0xB2C0             UXTB     R0,R0
   \   0000000A   0x.... 0x....      BL       spi_master_get_instance
   \   0000000E   0x0004             MOVS     R4,R0
    394              APP_ERROR_CHECK_BOOL(p_spi_instance != NULL);
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD001             BEQ      ??spi_master_evt_handler_reg_0
   \   00000014   0x2501             MOVS     R5,#+1
   \   00000016   0xE000             B        ??spi_master_evt_handler_reg_1
   \                     ??spi_master_evt_handler_reg_0: (+1)
   \   00000018   0x2500             MOVS     R5,#+0
   \                     ??spi_master_evt_handler_reg_1: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD104             BNE      ??spi_master_evt_handler_reg_2
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      BL       app_error_handler
    395          
    396              p_spi_instance->callback_event_handler = event_handler;
   \                     ??spi_master_evt_handler_reg_2: (+1)
   \   0000002A   0x6226             STR      R6,[R4, #+32]
    397              #else
    398              return;
    399              #endif
    400          }
   \   0000002C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    401          

   \                                 In section .text, align 2, keep-with-next
    402          uint32_t spi_master_send_recv(const spi_master_hw_instance_t spi_master_hw_instance,
    403                                        uint8_t * const p_tx_buf, const uint16_t tx_buf_len,
    404                                        uint8_t * const p_rx_buf, const uint16_t rx_buf_len)
    405          {
   \                     spi_master_send_recv: (+1)
   \   00000000   0xB5FF             PUSH     {R0-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x9F0C             LDR      R7,[SP, #+48]
    406              #if defined(SPI_MASTER_0_ENABLE) || defined(SPI_MASTER_1_ENABLE)
    407          
    408              volatile spi_master_instance_t * p_spi_instance = spi_master_get_instance(
    409                  spi_master_hw_instance);
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x7B00             LDRB     R0,[R0, #+12]
   \   0000000A   0x.... 0x....      BL       spi_master_get_instance
   \   0000000E   0x0004             MOVS     R4,R0
    410              APP_ERROR_CHECK_BOOL(p_spi_instance != NULL);
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD001             BEQ      ??spi_master_send_recv_0
   \   00000014   0x2501             MOVS     R5,#+1
   \   00000016   0xE000             B        ??spi_master_send_recv_1
   \                     ??spi_master_send_recv_0: (+1)
   \   00000018   0x2500             MOVS     R5,#+0
   \                     ??spi_master_send_recv_1: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD104             BNE      ??spi_master_send_recv_2
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      BL       app_error_handler
    411          
    412              uint32_t err_code   = NRF_SUCCESS;
   \                     ??spi_master_send_recv_2: (+1)
   \   0000002A   0x2600             MOVS     R6,#+0
    413              uint16_t max_length = 0;
   \   0000002C   0x2500             MOVS     R5,#+0
    414              
    415              uint8_t nested_critical_region = 0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x4669             MOV      R1,SP
   \   00000032   0x7108             STRB     R0,[R1, #+4]
    416              
    417              //Check if disable all IRQs flag is set
    418              if (p_spi_instance->disable_all_irq)
   \   00000034   0x2026             MOVS     R0,#+38
   \   00000036   0x5C20             LDRB     R0,[R4, R0]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD00B             BEQ      ??spi_master_send_recv_3
    419              {
    420                  //Disable interrupts.
    421                  APP_ERROR_CHECK(sd_nvic_critical_region_enter(&nested_critical_region));
   \   0000003C   0xA801             ADD      R0,SP,#+4
   \   0000003E   0xDF2E             SVC      0x2E
   \   00000040   0x9000             STR      R0,[SP, #+0]
   \   00000042   0x9800             LDR      R0,[SP, #+0]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD004             BEQ      ??spi_master_send_recv_4
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x9800             LDR      R0,[SP, #+0]
   \   0000004E   0x.... 0x....      BL       app_error_handler
   \                     ??spi_master_send_recv_4: (+1)
   \   00000052   0xE00B             B        ??spi_master_send_recv_5
    422              }
    423              else
    424              {
    425                  //Disable interrupt SPI.
    426                  APP_ERROR_CHECK(sd_nvic_DisableIRQ(p_spi_instance->irq_type));
   \                     ??spi_master_send_recv_3: (+1)
   \   00000054   0x2004             MOVS     R0,#+4
   \   00000056   0x5620             LDRSB    R0,[R4, R0]
   \   00000058   0xDF27             SVC      0x27
   \   0000005A   0x9000             STR      R0,[SP, #+0]
   \   0000005C   0x9800             LDR      R0,[SP, #+0]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD004             BEQ      ??spi_master_send_recv_6
   \   00000062   0x2200             MOVS     R2,#+0
   \   00000064   0x2100             MOVS     R1,#+0
   \   00000066   0x9800             LDR      R0,[SP, #+0]
   \   00000068   0x.... 0x....      BL       app_error_handler
    427              }
    428          
    429              //Initialize and perform data transfer
    430              if (p_spi_instance->state == SPI_MASTER_STATE_IDLE)
   \                     ??spi_master_send_recv_6: (+1)
   \                     ??spi_master_send_recv_5: (+1)
   \   0000006C   0x2024             MOVS     R0,#+36
   \   0000006E   0x5C20             LDRB     R0,[R4, R0]
   \   00000070   0x2802             CMP      R0,#+2
   \   00000072   0xD136             BNE      ??spi_master_send_recv_7
    431              {
    432                  max_length = (rx_buf_len > tx_buf_len) ? rx_buf_len : tx_buf_len;
   \   00000074   0x4668             MOV      R0,SP
   \   00000076   0x8A80             LDRH     R0,[R0, #+20]
   \   00000078   0xB2BF             UXTH     R7,R7
   \   0000007A   0x42B8             CMP      R0,R7
   \   0000007C   0xD201             BCS      ??spi_master_send_recv_8
   \   0000007E   0x003D             MOVS     R5,R7
   \   00000080   0xE001             B        ??spi_master_send_recv_9
   \                     ??spi_master_send_recv_8: (+1)
   \   00000082   0x4668             MOV      R0,SP
   \   00000084   0x8A85             LDRH     R5,[R0, #+20]
    433          
    434                  if (max_length > 0)
   \                     ??spi_master_send_recv_9: (+1)
   \   00000086   0xB2AD             UXTH     R5,R5
   \   00000088   0x2D00             CMP      R5,#+0
   \   0000008A   0xD027             BEQ      ??spi_master_send_recv_10
    435                  {
    436                      p_spi_instance->state        = SPI_MASTER_STATE_BUSY;
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0x2124             MOVS     R1,#+36
   \   00000090   0x5460             STRB     R0,[R4, R1]
    437                      p_spi_instance->bytes_count  = 0;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x8360             STRH     R0,[R4, #+26]
    438                      p_spi_instance->started_flag = false;
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x2125             MOVS     R1,#+37
   \   0000009A   0x5460             STRB     R0,[R4, R1]
    439                      p_spi_instance->max_length   = max_length;
   \   0000009C   0x8325             STRH     R5,[R4, #+24]
    440          
    441                      /* Initialize buffers */
    442                      spi_master_buffer_init(p_tx_buf,
    443                                             tx_buf_len,
    444                                             &(p_spi_instance->p_tx_buffer),
    445                                             &(p_spi_instance->tx_length),
    446                                             &(p_spi_instance->tx_index));
   \   0000009E   0x0020             MOVS     R0,R4
   \   000000A0   0x300E             ADDS     R0,R0,#+14
   \   000000A2   0x9000             STR      R0,[SP, #+0]
   \   000000A4   0x0023             MOVS     R3,R4
   \   000000A6   0x330C             ADDS     R3,R3,#+12
   \   000000A8   0x0022             MOVS     R2,R4
   \   000000AA   0x3208             ADDS     R2,R2,#+8
   \   000000AC   0x4668             MOV      R0,SP
   \   000000AE   0x8A81             LDRH     R1,[R0, #+20]
   \   000000B0   0x9804             LDR      R0,[SP, #+16]
   \   000000B2   0x.... 0x....      BL       spi_master_buffer_init
    447                      spi_master_buffer_init(p_rx_buf,
    448                                             rx_buf_len,
    449                                             &(p_spi_instance->p_rx_buffer),
    450                                             &(p_spi_instance->rx_length),
    451                                             &(p_spi_instance->rx_index));
   \   000000B6   0x0020             MOVS     R0,R4
   \   000000B8   0x3016             ADDS     R0,R0,#+22
   \   000000BA   0x9000             STR      R0,[SP, #+0]
   \   000000BC   0x0023             MOVS     R3,R4
   \   000000BE   0x3314             ADDS     R3,R3,#+20
   \   000000C0   0x0022             MOVS     R2,R4
   \   000000C2   0x3210             ADDS     R2,R2,#+16
   \   000000C4   0x0039             MOVS     R1,R7
   \   000000C6   0xB289             UXTH     R1,R1
   \   000000C8   0x9806             LDR      R0,[SP, #+24]
   \   000000CA   0x.... 0x....      BL       spi_master_buffer_init
    452          
    453                      nrf_gpio_pin_clear(p_spi_instance->pin_slave_select);
   \   000000CE   0x7F20             LDRB     R0,[R4, #+28]
   \   000000D0   0x.... 0x....      BL       nrf_gpio_pin_clear
    454                      spi_master_send_initial_bytes(p_spi_instance);
   \   000000D4   0x0020             MOVS     R0,R4
   \   000000D6   0x.... 0x....      BL       spi_master_send_initial_bytes
   \   000000DA   0xE004             B        ??spi_master_send_recv_11
    455                  }
    456                  else
    457                  {
    458                      err_code = NRF_ERROR_INVALID_PARAM;
   \                     ??spi_master_send_recv_10: (+1)
   \   000000DC   0x2007             MOVS     R0,#+7
   \   000000DE   0x0006             MOVS     R6,R0
   \   000000E0   0xE001             B        ??spi_master_send_recv_11
    459                  }
    460              }
    461              else
    462              {
    463                  err_code = NRF_ERROR_BUSY;
   \                     ??spi_master_send_recv_7: (+1)
   \   000000E2   0x2011             MOVS     R0,#+17
   \   000000E4   0x0006             MOVS     R6,R0
    464              }
    465              
    466              //Check if disable all IRQs flag is set.
    467              if (p_spi_instance->disable_all_irq)
   \                     ??spi_master_send_recv_11: (+1)
   \   000000E6   0x2026             MOVS     R0,#+38
   \   000000E8   0x5C20             LDRB     R0,[R4, R0]
   \   000000EA   0x2800             CMP      R0,#+0
   \   000000EC   0xD00C             BEQ      ??spi_master_send_recv_12
    468              {   
    469                  //Enable interrupts.
    470                  APP_ERROR_CHECK(sd_nvic_critical_region_exit(nested_critical_region));
   \   000000EE   0x4668             MOV      R0,SP
   \   000000F0   0x7900             LDRB     R0,[R0, #+4]
   \   000000F2   0xDF2F             SVC      0x2F
   \   000000F4   0x9000             STR      R0,[SP, #+0]
   \   000000F6   0x9800             LDR      R0,[SP, #+0]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD004             BEQ      ??spi_master_send_recv_13
   \   000000FC   0x2200             MOVS     R2,#+0
   \   000000FE   0x2100             MOVS     R1,#+0
   \   00000100   0x9800             LDR      R0,[SP, #+0]
   \   00000102   0x.... 0x....      BL       app_error_handler
   \                     ??spi_master_send_recv_13: (+1)
   \   00000106   0xE00B             B        ??spi_master_send_recv_14
    471              }
    472              else
    473              {
    474                  //Enable SPI interrupt.
    475                  APP_ERROR_CHECK(sd_nvic_EnableIRQ(p_spi_instance->irq_type));
   \                     ??spi_master_send_recv_12: (+1)
   \   00000108   0x2004             MOVS     R0,#+4
   \   0000010A   0x5620             LDRSB    R0,[R4, R0]
   \   0000010C   0xDF26             SVC      0x26
   \   0000010E   0x9000             STR      R0,[SP, #+0]
   \   00000110   0x9800             LDR      R0,[SP, #+0]
   \   00000112   0x2800             CMP      R0,#+0
   \   00000114   0xD004             BEQ      ??spi_master_send_recv_15
   \   00000116   0x2200             MOVS     R2,#+0
   \   00000118   0x2100             MOVS     R1,#+0
   \   0000011A   0x9800             LDR      R0,[SP, #+0]
   \   0000011C   0x.... 0x....      BL       app_error_handler
    476              }
    477          
    478              return err_code;
   \                     ??spi_master_send_recv_15: (+1)
   \                     ??spi_master_send_recv_14: (+1)
   \   00000120   0x0030             MOVS     R0,R6
   \   00000122   0xB007             ADD      SP,SP,#+28
   \   00000124   0xBDF0             POP      {R4-R7,PC}       ;; return
    479              #else
    480              return NRF_ERROR_NOT_SUPPORTED;
    481              #endif
    482          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x50000700         DC32     0x50000700

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x50000508         DC32     0x50000508

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x5000050C         DC32     0x5000050c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x40003108         DC32     0x40003108

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x40003304         DC32     0x40003304

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     m_spi_master_instances

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x0000051C         DC32     0x51c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x40003000         DC32     0x40003000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x0000050C         DC32     0x50c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x00000524         DC32     0x524

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x00000554         DC32     0x554

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x02 0x00          DC8 2, 0
   \   00000002   0x0000             DC16 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   SPI0_TWI0_IRQHandler
         8   -> spi_master_get_instance
         8   -> spi_master_send_recv_irq
       4   nrf_gpio_cfg_input
       0   nrf_gpio_cfg_output
       0   nrf_gpio_pin_clear
       0   nrf_gpio_pin_set
      32   spi_master_buffer_init
        32   -> app_error_handler
      16   spi_master_buffer_release
        16   -> app_error_handler
      16   spi_master_close
        16   -> app_error_handler
        16   -> nrf_gpio_cfg_input
        16   -> nrf_gpio_pin_set
        16   -> spi_master_get_instance
        16   -> spi_master_init_hw_instance
      24   spi_master_evt_handler_reg
        24   -> app_error_handler
        24   -> spi_master_get_instance
       4   spi_master_get_instance
      16   spi_master_get_state
        16   -> app_error_handler
        16   -> spi_master_get_instance
      24   spi_master_init_hw_instance
        24   -> app_error_handler
      24   spi_master_open
        24   -> app_error_handler
        24   -> nrf_gpio_cfg_input
        24   -> nrf_gpio_cfg_output
        24   -> nrf_gpio_pin_set
        24   -> spi_master_get_instance
        24   -> spi_master_init_hw_instance
      16   spi_master_send_initial_bytes
        16   -> app_error_handler
      48   spi_master_send_recv
        48   -> app_error_handler
        48   -> nrf_gpio_pin_clear
        48   -> spi_master_buffer_init
        48   -> spi_master_get_instance
        48   -> spi_master_send_initial_bytes
      16   spi_master_send_recv_irq
        16   -> app_error_handler
        16   -> nrf_gpio_pin_set
        16   -> spi_master_buffer_release
        16   -> spi_master_signal_evt
      24   spi_master_signal_evt
        24   -- Indirect call
        24   -> app_error_handler


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable7
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable9
       4  ?_0
      40  SPI0_TWI0_IRQHandler
      40  m_spi_master_instances
      18  nrf_gpio_cfg_input
      12  nrf_gpio_cfg_output
      10  nrf_gpio_pin_clear
      10  nrf_gpio_pin_set
     112  spi_master_buffer_init
      68  spi_master_buffer_release
     160  spi_master_close
      46  spi_master_evt_handler_reg
      26  spi_master_get_instance
      46  spi_master_get_state
     100  spi_master_init_hw_instance
     294  spi_master_open
     118  spi_master_send_initial_bytes
     294  spi_master_send_recv
     208  spi_master_send_recv_irq
      62  spi_master_signal_evt

 
    40 bytes in section .bss
     4 bytes in section .rodata
 1 672 bytes in section .text
 
 1 672 bytes of CODE  memory
     4 bytes of CONST memory
    40 bytes of DATA  memory

Errors: none
Warnings: none
