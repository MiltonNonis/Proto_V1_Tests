###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        14/Apr/2015  23:15:54
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\Dev_Tools\NordicSemi\nRF51-DK\nRF51_SDK_7.2.0_cf547b5\components\libraries\timer\app_timer.c
#    Command line =  
#        E:\Dev_Tools\NordicSemi\nRF51-DK\nRF51_SDK_7.2.0_cf547b5\components\libraries\timer\app_timer.c
#        -D NRF51 -D BOARD_PCA10028 -D BLE_STACK_SUPPORT_REQD -D S110 -D
#        SPI_MASTER_0_ENABLE -D ACCELEROMETER_ENABLE -lCN
#        E:\Professional\Nuzzle\Collar\FW\Proto_V1_Tests\examples\peripheral\spi_master\pca10028\Debug\List\
#        --diag_suppress Pe301,Pa082 -o
#        E:\Professional\Nuzzle\Collar\FW\Proto_V1_Tests\examples\peripheral\spi_master\pca10028\Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\Professional\Nuzzle\Collar\FW\Proto_V1_Tests\examples\peripheral\spi_master\pca10028\..\
#        -I
#        E:\Professional\Nuzzle\Collar\FW\Proto_V1_Tests\examples\peripheral\spi_master\pca10028\..\pca10028\
#        -I
#        E:\Professional\Nuzzle\Collar\FW\Proto_V1_Tests\examples\peripheral\spi_master\pca10028\..\devices\
#        -I
#        E:\Dev_Tools\NordicSemi\nRF51-DK\nRF51_SDK_7.2.0_cf547b5\components\drivers_nrf\hal\
#        -I
#        E:\Dev_Tools\NordicSemi\nRF51-DK\nRF51_SDK_7.2.0_cf547b5\components\drivers_nrf\spi_master\
#        -I
#        E:\Dev_Tools\NordicSemi\nRF51-DK\nRF51_SDK_7.2.0_cf547b5\components\libraries\gpiote\
#        -I
#        E:\Dev_Tools\NordicSemi\nRF51-DK\nRF51_SDK_7.2.0_cf547b5\components\libraries\scheduler\
#        -I
#        E:\Dev_Tools\NordicSemi\nRF51-DK\nRF51_SDK_7.2.0_cf547b5\components\libraries\timer\
#        -I
#        E:\Dev_Tools\NordicSemi\nRF51-DK\nRF51_SDK_7.2.0_cf547b5\components\libraries\util\
#        -I
#        E:\Dev_Tools\NordicSemi\nRF51-DK\nRF51_SDK_7.2.0_cf547b5\components\softdevice\s110\headers\
#        -I
#        E:\Dev_Tools\NordicSemi\nRF51-DK\nRF51_SDK_7.2.0_cf547b5\components\softdevice\common\softdevice_handler\
#        -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\" -On
#    List file    =  
#        E:\Professional\Nuzzle\Collar\FW\Proto_V1_Tests\examples\peripheral\spi_master\pca10028\Debug\List\app_timer.lst
#    Object file  =  
#        E:\Professional\Nuzzle\Collar\FW\Proto_V1_Tests\examples\peripheral\spi_master\pca10028\Debug\Obj\app_timer.o
#
###############################################################################

E:\Dev_Tools\NordicSemi\nRF51-DK\nRF51_SDK_7.2.0_cf547b5\components\libraries\timer\app_timer.c
      1          /* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
      2           *
      3           * The information contained herein is property of Nordic Semiconductor ASA.
      4           * Terms and conditions of usage are described in detail in NORDIC
      5           * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
      6           *
      7           * Licensees are granted free, non-transferable use of the information. NO
      8           * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
      9           * the file.
     10           *
     11           */
     12          
     13          #include "app_timer.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp bool is_word_aligned(void *)
   \                     is_word_aligned: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0780             LSLS     R0,R0,#+30
   \   00000004   0xD101             BNE      ??is_word_aligned_0
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xE000             B        ??is_word_aligned_1
   \                     ??is_word_aligned_0: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \                     ??is_word_aligned_1: (+1)
   \   0000000C   0xB2C0             UXTB     R0,R0
   \   0000000E   0xBD00             POP      {PC}             ;; return
     14          #include <stdlib.h>
     15          #include "nrf51.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x06C2             LSLS     R2,R0,#+27       ;; ZeroExtS R2,R0,#+27,#+27
   \   00000004   0x0ED2             LSRS     R2,R2,#+27
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR      R2,??DataTable12  ;; 0xe000e100
   \   0000000A   0x6011             STR      R1,[R2, #+0]
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x06C2             LSLS     R2,R0,#+27       ;; ZeroExtS R2,R0,#+27,#+27
   \   00000004   0x0ED2             LSRS     R2,R2,#+27
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR      R2,??DataTable12_1  ;; 0xe000e180
   \   0000000A   0x6011             STR      R1,[R2, #+0]
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_SetPendingIRQ(IRQn_Type)
   \                     NVIC_SetPendingIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x06C2             LSLS     R2,R0,#+27       ;; ZeroExtS R2,R0,#+27,#+27
   \   00000004   0x0ED2             LSRS     R2,R2,#+27
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR      R2,??DataTable12_2  ;; 0xe000e200
   \   0000000A   0x6011             STR      R1,[R2, #+0]
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_ClearPendingIRQ(IRQn_Type)
   \                     NVIC_ClearPendingIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x06C2             LSLS     R2,R0,#+27       ;; ZeroExtS R2,R0,#+27,#+27
   \   00000004   0x0ED2             LSRS     R2,R2,#+27
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR      R2,??DataTable12_3  ;; 0xe000e280
   \   0000000A   0x6011             STR      R1,[R2, #+0]
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_SetPriority(IRQn_Type, uint32_t)
   \                     NVIC_SetPriority: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB240             SXTB     R0,R0
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD522             BPL      ??NVIC_SetPriority_0
   \   00000008   0x....             LDR      R4,??DataTable12_4  ;; 0xe000ed1c
   \   0000000A   0xB240             SXTB     R0,R0
   \   0000000C   0x0702             LSLS     R2,R0,#+28       ;; ZeroExtS R2,R0,#+28,#+28
   \   0000000E   0x0F12             LSRS     R2,R2,#+28
   \   00000010   0x3A08             SUBS     R2,R2,#+8
   \   00000012   0x0015             MOVS     R5,R2
   \   00000014   0x08AD             LSRS     R5,R5,#+2
   \   00000016   0x2204             MOVS     R2,#+4
   \   00000018   0x4355             MULS     R5,R2,R5
   \   0000001A   0x....             LDR      R2,??DataTable12_4  ;; 0xe000ed1c
   \   0000001C   0xB240             SXTB     R0,R0
   \   0000001E   0x0703             LSLS     R3,R0,#+28       ;; ZeroExtS R3,R0,#+28,#+28
   \   00000020   0x0F1B             LSRS     R3,R3,#+28
   \   00000022   0x3B08             SUBS     R3,R3,#+8
   \   00000024   0x089B             LSRS     R3,R3,#+2
   \   00000026   0x2604             MOVS     R6,#+4
   \   00000028   0x4373             MULS     R3,R6,R3
   \   0000002A   0x58D2             LDR      R2,[R2, R3]
   \   0000002C   0x23FF             MOVS     R3,#+255
   \   0000002E   0x0786             LSLS     R6,R0,#+30       ;; ZeroExtS R6,R0,#+30,#+30
   \   00000030   0x0FB6             LSRS     R6,R6,#+30
   \   00000032   0x2708             MOVS     R7,#+8
   \   00000034   0x437E             MULS     R6,R7,R6
   \   00000036   0x40B3             LSLS     R3,R3,R6
   \   00000038   0x439A             BICS     R2,R2,R3
   \   0000003A   0x018B             LSLS     R3,R1,#+6
   \   0000003C   0xB2DB             UXTB     R3,R3
   \   0000003E   0x0786             LSLS     R6,R0,#+30       ;; ZeroExtS R6,R0,#+30,#+30
   \   00000040   0x0FB6             LSRS     R6,R6,#+30
   \   00000042   0x2708             MOVS     R7,#+8
   \   00000044   0x437E             MULS     R6,R7,R6
   \   00000046   0x40B3             LSLS     R3,R3,R6
   \   00000048   0x4313             ORRS     R3,R3,R2
   \   0000004A   0x5163             STR      R3,[R4, R5]
   \   0000004C   0xE01C             B        ??NVIC_SetPriority_1
   \                     ??NVIC_SetPriority_0: (+1)
   \   0000004E   0x....             LDR      R2,??DataTable13  ;; 0xe000e400
   \   00000050   0xB240             SXTB     R0,R0
   \   00000052   0x0003             MOVS     R3,R0
   \   00000054   0x089B             LSRS     R3,R3,#+2
   \   00000056   0x2404             MOVS     R4,#+4
   \   00000058   0x4363             MULS     R3,R4,R3
   \   0000005A   0x58D2             LDR      R2,[R2, R3]
   \   0000005C   0x23FF             MOVS     R3,#+255
   \   0000005E   0x0784             LSLS     R4,R0,#+30       ;; ZeroExtS R4,R0,#+30,#+30
   \   00000060   0x0FA4             LSRS     R4,R4,#+30
   \   00000062   0x2508             MOVS     R5,#+8
   \   00000064   0x436C             MULS     R4,R5,R4
   \   00000066   0x40A3             LSLS     R3,R3,R4
   \   00000068   0x439A             BICS     R2,R2,R3
   \   0000006A   0x018B             LSLS     R3,R1,#+6
   \   0000006C   0xB2DB             UXTB     R3,R3
   \   0000006E   0x0784             LSLS     R4,R0,#+30       ;; ZeroExtS R4,R0,#+30,#+30
   \   00000070   0x0FA4             LSRS     R4,R4,#+30
   \   00000072   0x2508             MOVS     R5,#+8
   \   00000074   0x436C             MULS     R4,R5,R4
   \   00000076   0x40A3             LSLS     R3,R3,R4
   \   00000078   0x4313             ORRS     R3,R3,R2
   \   0000007A   0x....             LDR      R2,??DataTable13  ;; 0xe000e400
   \   0000007C   0xB240             SXTB     R0,R0
   \   0000007E   0x0004             MOVS     R4,R0
   \   00000080   0x08A4             LSRS     R4,R4,#+2
   \   00000082   0x2504             MOVS     R5,#+4
   \   00000084   0x436C             MULS     R4,R5,R4
   \   00000086   0x5113             STR      R3,[R2, R4]
   \                     ??NVIC_SetPriority_1: (+1)
   \   00000088   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t NVIC_GetPriority(IRQn_Type)
   \                     NVIC_GetPriority: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB240             SXTB     R0,R0
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD512             BPL      ??NVIC_GetPriority_0
   \   00000008   0x....             LDR      R1,??DataTable12_4  ;; 0xe000ed1c
   \   0000000A   0xB240             SXTB     R0,R0
   \   0000000C   0x0702             LSLS     R2,R0,#+28       ;; ZeroExtS R2,R0,#+28,#+28
   \   0000000E   0x0F12             LSRS     R2,R2,#+28
   \   00000010   0x3A08             SUBS     R2,R2,#+8
   \   00000012   0x0892             LSRS     R2,R2,#+2
   \   00000014   0x2304             MOVS     R3,#+4
   \   00000016   0x435A             MULS     R2,R3,R2
   \   00000018   0x5889             LDR      R1,[R1, R2]
   \   0000001A   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   0000001C   0x0F80             LSRS     R0,R0,#+30
   \   0000001E   0x2208             MOVS     R2,#+8
   \   00000020   0x4350             MULS     R0,R2,R0
   \   00000022   0x40C1             LSRS     R1,R1,R0
   \   00000024   0x0008             MOVS     R0,R1
   \   00000026   0x0980             LSRS     R0,R0,#+6
   \   00000028   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   0000002A   0x0F80             LSRS     R0,R0,#+30
   \   0000002C   0xE00F             B        ??NVIC_GetPriority_1
   \                     ??NVIC_GetPriority_0: (+1)
   \   0000002E   0x....             LDR      R1,??DataTable13  ;; 0xe000e400
   \   00000030   0xB240             SXTB     R0,R0
   \   00000032   0x0002             MOVS     R2,R0
   \   00000034   0x0892             LSRS     R2,R2,#+2
   \   00000036   0x2304             MOVS     R3,#+4
   \   00000038   0x435A             MULS     R2,R3,R2
   \   0000003A   0x5889             LDR      R1,[R1, R2]
   \   0000003C   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   0000003E   0x0F80             LSRS     R0,R0,#+30
   \   00000040   0x2208             MOVS     R2,#+8
   \   00000042   0x4350             MULS     R0,R2,R0
   \   00000044   0x40C1             LSRS     R1,R1,R0
   \   00000046   0x0008             MOVS     R0,R1
   \   00000048   0x0980             LSRS     R0,R0,#+6
   \   0000004A   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   0000004C   0x0F80             LSRS     R0,R0,#+30
   \                     ??NVIC_GetPriority_1: (+1)
   \   0000004E   0xBD00             POP      {PC}             ;; return
     16          #include "nrf51_bitfields.h"
     17          #include "nrf_soc.h"
     18          #include "app_error.h"
     19          #include "nrf_delay.h"

   \                                 In section .text, align 4, keep-with-next
   \   static __interwork __softfp void nrf_delay_us(uint32_t volatile)
   \                     nrf_delay_us: (+1)
   \   00000000   0xB401             PUSH     {R0}
   \                     ??loop: (+1)
   \   00000002   0x1E40             SUBS R0, R0, #1
   \   00000004   0xBF00             NOP
   \   00000006   0xBF00             NOP
   \   00000008   0xBF00             NOP
   \   0000000A   0xBF00             NOP
   \   0000000C   0xBF00             NOP
   \   0000000E   0xBF00             NOP
   \   00000010   0xBF00             NOP
   \   00000012   0xBF00             NOP
   \   00000014   0xBF00             NOP
   \   00000016   0xBF00             NOP
   \   00000018   0xBF00             NOP
   \   0000001A   0xBF00             NOP
   \   0000001C   0xD1F1             BNE ??loop
   \   0000001E   0xB001             ADD      SP,SP,#+4
   \   00000020   0x4770             BX       LR               ;; return
     20          #include "app_util.h"
     21          #include "app_util_platform.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint8_t current_int_priority_get(void)
   \                     current_int_priority_get: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x....             LDR      R0,??DataTable14  ;; 0xe000ed04
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x05C5             LSLS     R5,R0,#+23       ;; ZeroExtS R5,R0,#+23,#+23
   \   00000008   0x0DED             LSRS     R5,R5,#+23
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD007             BEQ      ??current_int_priority_get_0
   \   0000000E   0x002C             MOVS     R4,R5
   \   00000010   0x3C10             SUBS     R4,R4,#+16
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xB240             SXTB     R0,R0
   \   00000016   0x.... 0x....      BL       NVIC_GetPriority
   \   0000001A   0xB2C0             UXTB     R0,R0
   \   0000001C   0xE000             B        ??current_int_priority_get_1
   \                     ??current_int_priority_get_0: (+1)
   \   0000001E   0x2004             MOVS     R0,#+4
   \                     ??current_int_priority_get_1: (+1)
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     22          
     23          #define RTC1_IRQ_PRI            APP_IRQ_PRIORITY_LOW                        /**< Priority of the RTC1 interrupt (used for checking for timeouts and executing timeout handlers). */
     24          #define SWI0_IRQ_PRI            APP_IRQ_PRIORITY_LOW                        /**< Priority of the SWI0 interrupt (used for updating the timer list). */
     25          
     26          // The current design assumes that both interrupt handlers run at the same interrupt level.
     27          // If this is to be changed, protection must be added to prevent them from interrupting each other
     28          // (e.g. by using guard/trigger flags).
     29          STATIC_ASSERT(RTC1_IRQ_PRI == SWI0_IRQ_PRI);
     30          
     31          #define MAX_RTC_COUNTER_VAL     0x00FFFFFF                                  /**< Maximum value of the RTC counter. */
     32          
     33          #define APP_HIGH_USER_ID        0                                           /**< User Id for the Application High "user". */
     34          #define APP_LOW_USER_ID         1                                           /**< User Id for the Application Low "user". */
     35          #define THREAD_MODE_USER_ID     2                                           /**< User Id for the Thread Mode "user". */
     36          
     37          #define RTC_COMPARE_OFFSET_MIN  3                                           /**< Minimum offset between the current RTC counter value and the Capture Compare register. Although the nRF51 Series User Specification recommends this value to be 2, we use 3 to be safer.*/
     38          
     39          #define MAX_RTC_TASKS_DELAY     47                                          /**< Maximum delay until an RTC task is executed. */
     40          
     41          /**@brief Timer allocation state type. */
     42          typedef enum
     43          {
     44              STATE_FREE,                                                             /**< The timer node is available. */
     45              STATE_ALLOCATED                                                         /**< The timer node has been allocated. */
     46          } timer_alloc_state_t;
     47          
     48          /**@brief Timer node type. The nodes will be used form a linked list of running timers. */
     49          typedef struct
     50          {
     51              timer_alloc_state_t         state;                                      /**< Timer allocation state. */
     52              app_timer_mode_t            mode;                                       /**< Timer mode. */
     53              uint32_t                    ticks_to_expire;                            /**< Number of ticks from previous timer interrupt to timer expiry. */
     54              uint32_t                    ticks_at_start;                             /**< Current RTC counter value when the timer was started. */
     55              uint32_t                    ticks_first_interval;                       /**< Number of ticks in the first timer interval. */
     56              uint32_t                    ticks_periodic_interval;                    /**< Timer period (for repeating timers). */
     57              bool                        is_running;                                 /**< True if timer is running, False otherwise. */
     58              app_timer_timeout_handler_t p_timeout_handler;                          /**< Pointer to function to be executed when the timer expires. */
     59              void *                      p_context;                                  /**< General purpose pointer. Will be passed to the timeout handler when the timer expires. */
     60              app_timer_id_t              next;                                       /**< Id of next timer in list of running timers. */
     61          } timer_node_t;
     62          
     63          STATIC_ASSERT(sizeof(timer_node_t) <= APP_TIMER_NODE_SIZE);
     64          STATIC_ASSERT(sizeof(timer_node_t) % 4 == 0);
     65          
     66          /**@brief Set of available timer operation types. */
     67          typedef enum
     68          {
     69              TIMER_USER_OP_TYPE_NONE,                                                /**< Invalid timer operation type. */
     70              TIMER_USER_OP_TYPE_START,                                               /**< Timer operation type Start. */
     71              TIMER_USER_OP_TYPE_STOP,                                                /**< Timer operation type Stop. */
     72              TIMER_USER_OP_TYPE_STOP_ALL                                             /**< Timer operation type Stop All. */
     73          } timer_user_op_type_t;
     74          
     75          /**@brief Structure describing a timer start operation. */
     76          typedef struct
     77          {
     78              uint32_t ticks_at_start;                                                /**< Current RTC counter value when the timer was started. */
     79              uint32_t ticks_first_interval;                                          /**< Number of ticks in the first timer interval. */
     80              uint32_t ticks_periodic_interval;                                       /**< Timer period (for repeating timers). */
     81              void *   p_context;                                                     /**< General purpose pointer. Will be passed to the timeout handler when the timer expires. */
     82          } timer_user_op_start_t;
     83          
     84          /**@brief Structure describing a timer operation. */
     85          typedef struct
     86          {
     87              timer_user_op_type_t op_type;                                           /**< Timer operation type. */
     88              app_timer_id_t       timer_id;                                          /**< Id of timer on which the operation is to be performed. */
     89              union
     90              {
     91                  timer_user_op_start_t start;                                        /**< Structure describing a timer start operation. */
     92              } params;
     93          } timer_user_op_t;
     94          
     95          STATIC_ASSERT(sizeof(timer_user_op_t) <= APP_TIMER_USER_OP_SIZE);
     96          STATIC_ASSERT(sizeof(timer_user_op_t) % 4 == 0);
     97          
     98          /**@brief Structure describing a timer user.
     99           *
    100           * @details For each user of the timer module, there will be a timer operations queue. This queue
    101           *          will hold timer operations issued by this user until the timer interrupt handler
    102           *          processes these operations. For the current implementation, there will be one user for
    103           *          each interrupt level available to the application (APP_HIGH, APP_LOW and THREAD_MODE),
    104           *          but the module can easily be modified to e.g. have one queue per process when using an
    105           *          RTOS. The purpose of the queues is to be able to have a completely lockless timer
    106           *          implementation.
    107           */
    108          typedef struct
    109          {
    110              uint8_t           first;                                                    /**< Index of first entry to have been inserted in the queue (i.e. the next entry to be executed). */
    111              uint8_t           last;                                                     /**< Index of last entry to have been inserted in the queue. */
    112              uint8_t           user_op_queue_size;                                       /**< Queue size. */
    113              timer_user_op_t * p_user_op_queue;                                          /**< Queue buffer. */
    114          } timer_user_t;
    115          
    116          STATIC_ASSERT(sizeof(timer_user_t) == APP_TIMER_USER_SIZE);
    117          STATIC_ASSERT(sizeof(timer_user_t) % 4 == 0);
    118          
    119          /**@brief User id type.
    120           *
    121           * @details In the current implementation, this will automatically be generated from the current
    122           *          interrupt level.
    123           */
    124          typedef uint32_t timer_user_id_t;
    125          
    126          #define TIMER_NULL                  ((app_timer_id_t)(0 - 1))                   /**< Invalid timer id. */
    127          #define CONTEXT_QUEUE_SIZE_MAX      (2)                                         /**< Timer internal elapsed ticks queue size. */
    128          

   \                                 In section .bss, align 1
    129          static uint8_t                       m_node_array_size;                         /**< Size of timer node array. */
   \                     m_node_array_size:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    130          static timer_node_t *                mp_nodes = NULL;                           /**< Array of timer nodes. */
   \                     mp_nodes:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
    131          static uint8_t                       m_user_array_size;                         /**< Size of timer user array. */
   \                     m_user_array_size:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    132          static timer_user_t *                mp_users;                                  /**< Array of timer users. */
   \                     mp_users:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    133          static app_timer_id_t                m_timer_id_head;                           /**< First timer in list of running timers. */
   \                     m_timer_id_head:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    134          static uint32_t                      m_ticks_latest;                            /**< Last known RTC counter value. */
   \                     m_ticks_latest:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    135          static uint32_t                      m_ticks_elapsed[CONTEXT_QUEUE_SIZE_MAX];   /**< Timer internal elapsed ticks queue. */
   \                     m_ticks_elapsed:
   \   00000000                      DS8 8

   \                                 In section .bss, align 1
    136          static uint8_t                       m_ticks_elapsed_q_read_ind;                /**< Timer internal elapsed ticks queue read index. */
   \                     m_ticks_elapsed_q_read_ind:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    137          static uint8_t                       m_ticks_elapsed_q_write_ind;               /**< Timer internal elapsed ticks queue write index. */
   \                     m_ticks_elapsed_q_write_ind:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    138          static app_timer_evt_schedule_func_t m_evt_schedule_func;                       /**< Pointer to function for propagating timeout events to the scheduler. */
   \                     m_evt_schedule_func:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
    139          static bool                          m_rtc1_running;                            /**< Boolean indicating if RTC1 is running. */
   \                     m_rtc1_running:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    140          static bool                          m_rtc1_reset;                              /**< Boolean indicating if RTC1 counter has been reset due to last timer removed from timer list during the timer list handling. */
   \                     m_rtc1_reset:
   \   00000000                      DS8 1
    141           
    142          
    143          /**@brief Function for initializing the RTC1 counter.
    144           *
    145           * @param[in] prescaler   Value of the RTC1 PRESCALER register. Set to 0 for no prescaling.
    146           */

   \                                 In section .text, align 2, keep-with-next
    147          static void rtc1_init(uint32_t prescaler)
    148          {
   \                     rtc1_init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    149              NRF_RTC1->PRESCALER = prescaler;
   \   00000004   0x....             LDR      R0,??DataTable15  ;; 0x40011508
   \   00000006   0x6004             STR      R4,[R0, #+0]
    150              NVIC_SetPriority(RTC1_IRQn, RTC1_IRQ_PRI);
   \   00000008   0x2103             MOVS     R1,#+3
   \   0000000A   0x2011             MOVS     R0,#+17
   \   0000000C   0x.... 0x....      BL       NVIC_SetPriority
    151          }
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
    152          
    153          
    154          /**@brief Function for starting the RTC1 timer.
    155           */

   \                                 In section .text, align 2, keep-with-next
    156          static void rtc1_start(void)
    157          {
   \                     rtc1_start: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    158              NRF_RTC1->EVTENSET = RTC_EVTEN_COMPARE0_Msk;
   \   00000002   0x2080             MOVS     R0,#+128
   \   00000004   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \   00000006   0x....             LDR      R1,??DataTable14_1  ;; 0x40011344
   \   00000008   0x6008             STR      R0,[R1, #+0]
    159              NRF_RTC1->INTENSET = RTC_INTENSET_COMPARE0_Msk;
   \   0000000A   0x2080             MOVS     R0,#+128
   \   0000000C   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \   0000000E   0x....             LDR      R1,??DataTable14_2  ;; 0x40011304
   \   00000010   0x6008             STR      R0,[R1, #+0]
    160          
    161              NVIC_ClearPendingIRQ(RTC1_IRQn);
   \   00000012   0x2011             MOVS     R0,#+17
   \   00000014   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    162              NVIC_EnableIRQ(RTC1_IRQn);
   \   00000018   0x2011             MOVS     R0,#+17
   \   0000001A   0x.... 0x....      BL       NVIC_EnableIRQ
    163          
    164              NRF_RTC1->TASKS_START = 1;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x....             LDR      R1,??DataTable14_3  ;; 0x40011000
   \   00000022   0x6008             STR      R0,[R1, #+0]
    165              nrf_delay_us(MAX_RTC_TASKS_DELAY);
   \   00000024   0x202F             MOVS     R0,#+47
   \   00000026   0x.... 0x....      BL       nrf_delay_us
    166          
    167              m_rtc1_running = true;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x....             LDR      R1,??DataTable15_1
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
    168          }
   \   00000030   0xBD01             POP      {R0,PC}          ;; return
    169          
    170          
    171          /**@brief Function for stopping the RTC1 timer.
    172           */

   \                                 In section .text, align 2, keep-with-next
    173          static void rtc1_stop(void)
    174          {
   \                     rtc1_stop: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    175              NVIC_DisableIRQ(RTC1_IRQn);
   \   00000002   0x2011             MOVS     R0,#+17
   \   00000004   0x.... 0x....      BL       NVIC_DisableIRQ
    176          
    177              NRF_RTC1->EVTENCLR = RTC_EVTEN_COMPARE0_Msk;
   \   00000008   0x2080             MOVS     R0,#+128
   \   0000000A   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \   0000000C   0x....             LDR      R1,??DataTable15_2  ;; 0x40011348
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    178              NRF_RTC1->INTENCLR = RTC_INTENSET_COMPARE0_Msk;
   \   00000010   0x2080             MOVS     R0,#+128
   \   00000012   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \   00000014   0x....             LDR      R1,??DataTable15_3  ;; 0x40011308
   \   00000016   0x6008             STR      R0,[R1, #+0]
    179          
    180              NRF_RTC1->TASKS_STOP = 1;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x....             LDR      R1,??DataTable15_4  ;; 0x40011004
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    181              nrf_delay_us(MAX_RTC_TASKS_DELAY);
   \   0000001E   0x202F             MOVS     R0,#+47
   \   00000020   0x.... 0x....      BL       nrf_delay_us
    182          
    183              NRF_RTC1->TASKS_CLEAR = 1;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x....             LDR      R1,??DataTable15_5  ;; 0x40011008
   \   00000028   0x6008             STR      R0,[R1, #+0]
    184              m_ticks_latest        = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x....             LDR      R1,??DataTable15_6
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    185              nrf_delay_us(MAX_RTC_TASKS_DELAY);
   \   00000030   0x202F             MOVS     R0,#+47
   \   00000032   0x.... 0x....      BL       nrf_delay_us
    186          
    187              m_rtc1_running = false;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x....             LDR      R1,??DataTable15_1
   \   0000003A   0x7008             STRB     R0,[R1, #+0]
    188          }
   \   0000003C   0xBD01             POP      {R0,PC}          ;; return
    189          
    190          
    191          /**@brief Function for returning the current value of the RTC1 counter.
    192           *
    193           * @return     Current value of the RTC1 counter.
    194           */

   \                                 In section .text, align 2, keep-with-next
    195          static __INLINE uint32_t rtc1_counter_get(void)
    196          {
    197              return NRF_RTC1->COUNTER;
   \                     rtc1_counter_get: (+1)
   \   00000000   0x....             LDR      R0,??DataTable16  ;; 0x40011504
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    198          }
    199          
    200          
    201          /**@brief Function for computing the difference between two RTC1 counter values.
    202           *
    203           * @return     Number of ticks elapsed from ticks_old to ticks_now.
    204           */

   \                                 In section .text, align 2, keep-with-next
    205          static __INLINE uint32_t ticks_diff_get(uint32_t ticks_now, uint32_t ticks_old)
    206          {
    207              return ((ticks_now - ticks_old) & MAX_RTC_COUNTER_VAL);
   \                     ticks_diff_get: (+1)
   \   00000000   0x1A40             SUBS     R0,R0,R1
   \   00000002   0x0200             LSLS     R0,R0,#+8        ;; ZeroExtS R0,R0,#+8,#+8
   \   00000004   0x0A00             LSRS     R0,R0,#+8
   \   00000006   0x4770             BX       LR               ;; return
    208          }
    209          
    210          
    211          /**@brief Function for setting the RTC1 Capture Compare register 0, and enabling the corresponding
    212           *        event.
    213           *
    214           * @param[in] value   New value of Capture Compare register 0.
    215           */

   \                                 In section .text, align 2, keep-with-next
    216          static __INLINE void rtc1_compare0_set(uint32_t value)
    217          {
    218              NRF_RTC1->CC[0] = value;
   \                     rtc1_compare0_set: (+1)
   \   00000000   0x....             LDR      R1,??DataTable16_1  ;; 0x40011540
   \   00000002   0x6008             STR      R0,[R1, #+0]
    219          }
   \   00000004   0x4770             BX       LR               ;; return
    220          
    221          
    222          /**@brief Function for inserting a timer in the timer list.
    223           *
    224           * @param[in]  timer_id   Id of timer to insert.
    225           */

   \                                 In section .text, align 2, keep-with-next
    226          static void timer_list_insert(app_timer_id_t timer_id)
    227          {
   \                     timer_list_insert: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    228              timer_node_t * p_timer = &mp_nodes[timer_id];
   \   00000002   0x....             LDR      R1,??DataTable16_2
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x2224             MOVS     R2,#+36
   \   00000008   0x4342             MULS     R2,R0,R2
   \   0000000A   0x1889             ADDS     R1,R1,R2
    229              
    230              if (m_timer_id_head == TIMER_NULL)
   \   0000000C   0x....             LDR      R2,??DataTable16_3
   \   0000000E   0x6812             LDR      R2,[R2, #+0]
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0x43DB             MVNS     R3,R3            ;; #-1
   \   00000014   0x429A             CMP      R2,R3
   \   00000016   0xD102             BNE      ??timer_list_insert_0
    231              {
    232                  m_timer_id_head = timer_id;
   \   00000018   0x....             LDR      R2,??DataTable16_3
   \   0000001A   0x6010             STR      R0,[R2, #+0]
   \   0000001C   0xE05E             B        ??timer_list_insert_1
    233              }
    234              else
    235              {
    236                  if (p_timer->ticks_to_expire <= mp_nodes[m_timer_id_head].ticks_to_expire)
   \                     ??timer_list_insert_0: (+1)
   \   0000001E   0x....             LDR      R2,??DataTable16_2
   \   00000020   0x6812             LDR      R2,[R2, #+0]
   \   00000022   0x....             LDR      R3,??DataTable16_3
   \   00000024   0x681B             LDR      R3,[R3, #+0]
   \   00000026   0x2424             MOVS     R4,#+36
   \   00000028   0x4363             MULS     R3,R4,R3
   \   0000002A   0x18D2             ADDS     R2,R2,R3
   \   0000002C   0x6852             LDR      R2,[R2, #+4]
   \   0000002E   0x684B             LDR      R3,[R1, #+4]
   \   00000030   0x429A             CMP      R2,R3
   \   00000032   0xD317             BCC      ??timer_list_insert_2
    237                  {
    238                      mp_nodes[m_timer_id_head].ticks_to_expire -= p_timer->ticks_to_expire;
   \   00000034   0x....             LDR      R2,??DataTable16_2
   \   00000036   0x6812             LDR      R2,[R2, #+0]
   \   00000038   0x....             LDR      R3,??DataTable16_3
   \   0000003A   0x681B             LDR      R3,[R3, #+0]
   \   0000003C   0x2424             MOVS     R4,#+36
   \   0000003E   0x4363             MULS     R3,R4,R3
   \   00000040   0x18D2             ADDS     R2,R2,R3
   \   00000042   0x6852             LDR      R2,[R2, #+4]
   \   00000044   0x684B             LDR      R3,[R1, #+4]
   \   00000046   0x1AD2             SUBS     R2,R2,R3
   \   00000048   0x....             LDR      R3,??DataTable16_2
   \   0000004A   0x681B             LDR      R3,[R3, #+0]
   \   0000004C   0x....             LDR      R4,??DataTable16_3
   \   0000004E   0x6824             LDR      R4,[R4, #+0]
   \   00000050   0x2524             MOVS     R5,#+36
   \   00000052   0x436C             MULS     R4,R5,R4
   \   00000054   0x191B             ADDS     R3,R3,R4
   \   00000056   0x605A             STR      R2,[R3, #+4]
    239                      
    240                      p_timer->next   = m_timer_id_head;
   \   00000058   0x....             LDR      R2,??DataTable16_3
   \   0000005A   0x6812             LDR      R2,[R2, #+0]
   \   0000005C   0x620A             STR      R2,[R1, #+32]
    241                      m_timer_id_head = timer_id;
   \   0000005E   0x....             LDR      R2,??DataTable16_3
   \   00000060   0x6010             STR      R0,[R2, #+0]
   \   00000062   0xE03B             B        ??timer_list_insert_1
    242                  }
    243                  else
    244                  {
    245                      app_timer_id_t previous;
    246                      app_timer_id_t current;
    247                      uint32_t       ticks_to_expire;
    248          
    249                      ticks_to_expire = p_timer->ticks_to_expire;
   \                     ??timer_list_insert_2: (+1)
   \   00000064   0x684D             LDR      R5,[R1, #+4]
   \   00000066   0x002C             MOVS     R4,R5
    250                      previous        = m_timer_id_head;
   \   00000068   0x....             LDR      R5,??DataTable16_3
   \   0000006A   0x682D             LDR      R5,[R5, #+0]
   \   0000006C   0x002A             MOVS     R2,R5
    251                      current         = m_timer_id_head;
   \   0000006E   0x....             LDR      R5,??DataTable16_3
   \   00000070   0x682D             LDR      R5,[R5, #+0]
   \   00000072   0x002B             MOVS     R3,R5
    252                      
    253                      while ((current != TIMER_NULL) && (ticks_to_expire > mp_nodes[current].ticks_to_expire))
   \                     ??timer_list_insert_3: (+1)
   \   00000074   0x2500             MOVS     R5,#+0
   \   00000076   0x43ED             MVNS     R5,R5            ;; #-1
   \   00000078   0x42AB             CMP      R3,R5
   \   0000007A   0xD016             BEQ      ??timer_list_insert_4
   \   0000007C   0x....             LDR      R5,??DataTable16_2
   \   0000007E   0x682D             LDR      R5,[R5, #+0]
   \   00000080   0x2624             MOVS     R6,#+36
   \   00000082   0x435E             MULS     R6,R3,R6
   \   00000084   0x19AD             ADDS     R5,R5,R6
   \   00000086   0x686D             LDR      R5,[R5, #+4]
   \   00000088   0x42A5             CMP      R5,R4
   \   0000008A   0xD20E             BCS      ??timer_list_insert_4
    254                      {
    255                          ticks_to_expire -= mp_nodes[current].ticks_to_expire;
   \   0000008C   0x....             LDR      R5,??DataTable16_2
   \   0000008E   0x682D             LDR      R5,[R5, #+0]
   \   00000090   0x2624             MOVS     R6,#+36
   \   00000092   0x435E             MULS     R6,R3,R6
   \   00000094   0x19AD             ADDS     R5,R5,R6
   \   00000096   0x686D             LDR      R5,[R5, #+4]
   \   00000098   0x1B64             SUBS     R4,R4,R5
    256                          previous         = current;
   \   0000009A   0x001A             MOVS     R2,R3
    257                          current          = mp_nodes[current].next;
   \   0000009C   0x....             LDR      R5,??DataTable16_2
   \   0000009E   0x682D             LDR      R5,[R5, #+0]
   \   000000A0   0x2624             MOVS     R6,#+36
   \   000000A2   0x4373             MULS     R3,R6,R3
   \   000000A4   0x18EB             ADDS     R3,R5,R3
   \   000000A6   0x6A1B             LDR      R3,[R3, #+32]
   \   000000A8   0xE7E4             B        ??timer_list_insert_3
    258                      }
    259          
    260                      if (current != TIMER_NULL)
   \                     ??timer_list_insert_4: (+1)
   \   000000AA   0x2500             MOVS     R5,#+0
   \   000000AC   0x43ED             MVNS     R5,R5            ;; #-1
   \   000000AE   0x42AB             CMP      R3,R5
   \   000000B0   0xD00C             BEQ      ??timer_list_insert_5
    261                      {
    262                          mp_nodes[current].ticks_to_expire -= ticks_to_expire;
   \   000000B2   0x....             LDR      R5,??DataTable16_2
   \   000000B4   0x682D             LDR      R5,[R5, #+0]
   \   000000B6   0x2624             MOVS     R6,#+36
   \   000000B8   0x435E             MULS     R6,R3,R6
   \   000000BA   0x19AD             ADDS     R5,R5,R6
   \   000000BC   0x686D             LDR      R5,[R5, #+4]
   \   000000BE   0x1B2D             SUBS     R5,R5,R4
   \   000000C0   0x....             LDR      R6,??DataTable16_2
   \   000000C2   0x6836             LDR      R6,[R6, #+0]
   \   000000C4   0x2724             MOVS     R7,#+36
   \   000000C6   0x435F             MULS     R7,R3,R7
   \   000000C8   0x19F6             ADDS     R6,R6,R7
   \   000000CA   0x6075             STR      R5,[R6, #+4]
    263                      }
    264          
    265                      p_timer->ticks_to_expire = ticks_to_expire;
   \                     ??timer_list_insert_5: (+1)
   \   000000CC   0x604C             STR      R4,[R1, #+4]
    266                      p_timer->next            = current;
   \   000000CE   0x620B             STR      R3,[R1, #+32]
    267                      mp_nodes[previous].next  = timer_id;
   \   000000D0   0x....             LDR      R5,??DataTable16_2
   \   000000D2   0x682D             LDR      R5,[R5, #+0]
   \   000000D4   0x2624             MOVS     R6,#+36
   \   000000D6   0x4372             MULS     R2,R6,R2
   \   000000D8   0x18AA             ADDS     R2,R5,R2
   \   000000DA   0x6210             STR      R0,[R2, #+32]
    268                  }
    269              }
    270          }
   \                     ??timer_list_insert_1: (+1)
   \   000000DC   0xBDF0             POP      {R4-R7,PC}       ;; return
    271          
    272          
    273          /**@brief Function for removing a timer from the timer queue.
    274           *
    275           * @param[in]  timer_id   Id of timer to remove.
    276           */

   \                                 In section .text, align 2, keep-with-next
    277          static void timer_list_remove(app_timer_id_t timer_id)
    278          {
   \                     timer_list_remove: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    279              app_timer_id_t previous;
    280              app_timer_id_t current;
    281              uint32_t       timeout;
    282          
    283              // Find the timer's position in timer list.
    284              previous = m_timer_id_head;
   \   00000002   0x....             LDR      R4,??DataTable16_3
   \   00000004   0x6824             LDR      R4,[R4, #+0]
   \   00000006   0x0021             MOVS     R1,R4
    285              current  = previous;
   \   00000008   0x000A             MOVS     R2,R1
    286              
    287              while (current != TIMER_NULL)
   \                     ??timer_list_remove_0: (+1)
   \   0000000A   0x2400             MOVS     R4,#+0
   \   0000000C   0x43E4             MVNS     R4,R4            ;; #-1
   \   0000000E   0x42A2             CMP      R2,R4
   \   00000010   0xD009             BEQ      ??timer_list_remove_1
    288              {
    289                  if (current == timer_id)
   \   00000012   0x4282             CMP      R2,R0
   \   00000014   0xD007             BEQ      ??timer_list_remove_1
    290                  {
    291                      break;
    292                  }
    293                  previous = current;
   \                     ??timer_list_remove_2: (+1)
   \   00000016   0x0011             MOVS     R1,R2
    294                  current  = mp_nodes[current].next;
   \   00000018   0x....             LDR      R4,??DataTable16_2
   \   0000001A   0x6824             LDR      R4,[R4, #+0]
   \   0000001C   0x2524             MOVS     R5,#+36
   \   0000001E   0x436A             MULS     R2,R5,R2
   \   00000020   0x18A2             ADDS     R2,R4,R2
   \   00000022   0x6A12             LDR      R2,[R2, #+32]
   \   00000024   0xE7F1             B        ??timer_list_remove_0
    295              }
    296          
    297              // Timer not in active list.
    298              if (current == TIMER_NULL)
   \                     ??timer_list_remove_1: (+1)
   \   00000026   0x2400             MOVS     R4,#+0
   \   00000028   0x43E4             MVNS     R4,R4            ;; #-1
   \   0000002A   0x42A2             CMP      R2,R4
   \   0000002C   0xD045             BEQ      ??timer_list_remove_3
    299              {
    300                  return;
    301              }
    302          
    303              // Timer is the first in the list
    304              if (previous == current)
   \                     ??timer_list_remove_4: (+1)
   \   0000002E   0x4291             CMP      R1,R2
   \   00000030   0xD118             BNE      ??timer_list_remove_5
    305              {
    306                  m_timer_id_head = mp_nodes[m_timer_id_head].next;
   \   00000032   0x....             LDR      R4,??DataTable16_2
   \   00000034   0x6824             LDR      R4,[R4, #+0]
   \   00000036   0x....             LDR      R5,??DataTable16_3
   \   00000038   0x682D             LDR      R5,[R5, #+0]
   \   0000003A   0x2624             MOVS     R6,#+36
   \   0000003C   0x4375             MULS     R5,R6,R5
   \   0000003E   0x1964             ADDS     R4,R4,R5
   \   00000040   0x6A24             LDR      R4,[R4, #+32]
   \   00000042   0x....             LDR      R5,??DataTable16_3
   \   00000044   0x602C             STR      R4,[R5, #+0]
    307          
    308                  // No more timers in the list. Reset RTC1 in case Start timer operations are present in the queue.
    309                  if (m_timer_id_head == TIMER_NULL)
   \   00000046   0x....             LDR      R4,??DataTable16_3
   \   00000048   0x6824             LDR      R4,[R4, #+0]
   \   0000004A   0x2500             MOVS     R5,#+0
   \   0000004C   0x43ED             MVNS     R5,R5            ;; #-1
   \   0000004E   0x42AC             CMP      R4,R5
   \   00000050   0xD108             BNE      ??timer_list_remove_5
    310                  {
    311                      NRF_RTC1->TASKS_CLEAR = 1;
   \   00000052   0x2401             MOVS     R4,#+1
   \   00000054   0x....             LDR      R5,??DataTable15_5  ;; 0x40011008
   \   00000056   0x602C             STR      R4,[R5, #+0]
    312                      m_ticks_latest        = 0;
   \   00000058   0x2400             MOVS     R4,#+0
   \   0000005A   0x....             LDR      R5,??DataTable15_6
   \   0000005C   0x602C             STR      R4,[R5, #+0]
    313                      m_rtc1_reset          = true;
   \   0000005E   0x2401             MOVS     R4,#+1
   \   00000060   0x....             LDR      R5,??DataTable18
   \   00000062   0x702C             STRB     R4,[R5, #+0]
    314                  }
    315              }
    316          
    317              // Remaining timeout between next timeout.
    318              timeout = mp_nodes[current].ticks_to_expire;
   \                     ??timer_list_remove_5: (+1)
   \   00000064   0x....             LDR      R4,??DataTable16_2
   \   00000066   0x6824             LDR      R4,[R4, #+0]
   \   00000068   0x2524             MOVS     R5,#+36
   \   0000006A   0x4355             MULS     R5,R2,R5
   \   0000006C   0x1964             ADDS     R4,R4,R5
   \   0000006E   0x6864             LDR      R4,[R4, #+4]
   \   00000070   0x0023             MOVS     R3,R4
    319          
    320              // Link previous timer with next of this timer, i.e. removing the timer from list.
    321              mp_nodes[previous].next = mp_nodes[current].next;
   \   00000072   0x....             LDR      R4,??DataTable16_2
   \   00000074   0x6824             LDR      R4,[R4, #+0]
   \   00000076   0x2524             MOVS     R5,#+36
   \   00000078   0x4355             MULS     R5,R2,R5
   \   0000007A   0x1964             ADDS     R4,R4,R5
   \   0000007C   0x6A24             LDR      R4,[R4, #+32]
   \   0000007E   0x....             LDR      R5,??DataTable16_2
   \   00000080   0x682D             LDR      R5,[R5, #+0]
   \   00000082   0x2624             MOVS     R6,#+36
   \   00000084   0x434E             MULS     R6,R1,R6
   \   00000086   0x19AD             ADDS     R5,R5,R6
   \   00000088   0x622C             STR      R4,[R5, #+32]
    322          
    323              // If this is not the last timer, increment the next timer by this timer timeout.
    324              current = mp_nodes[previous].next;
   \   0000008A   0x....             LDR      R4,??DataTable16_2
   \   0000008C   0x6824             LDR      R4,[R4, #+0]
   \   0000008E   0x2524             MOVS     R5,#+36
   \   00000090   0x434D             MULS     R5,R1,R5
   \   00000092   0x1964             ADDS     R4,R4,R5
   \   00000094   0x6A24             LDR      R4,[R4, #+32]
   \   00000096   0x0022             MOVS     R2,R4
    325              if (current != TIMER_NULL)
   \   00000098   0x2400             MOVS     R4,#+0
   \   0000009A   0x43E4             MVNS     R4,R4            ;; #-1
   \   0000009C   0x42A2             CMP      R2,R4
   \   0000009E   0xD00C             BEQ      ??timer_list_remove_6
    326              {
    327                  mp_nodes[current].ticks_to_expire += timeout;
   \   000000A0   0x....             LDR      R4,??DataTable16_2
   \   000000A2   0x6824             LDR      R4,[R4, #+0]
   \   000000A4   0x2524             MOVS     R5,#+36
   \   000000A6   0x4355             MULS     R5,R2,R5
   \   000000A8   0x1964             ADDS     R4,R4,R5
   \   000000AA   0x6864             LDR      R4,[R4, #+4]
   \   000000AC   0x18E4             ADDS     R4,R4,R3
   \   000000AE   0x....             LDR      R5,??DataTable16_2
   \   000000B0   0x682D             LDR      R5,[R5, #+0]
   \   000000B2   0x2624             MOVS     R6,#+36
   \   000000B4   0x4356             MULS     R6,R2,R6
   \   000000B6   0x19AD             ADDS     R5,R5,R6
   \   000000B8   0x606C             STR      R4,[R5, #+4]
    328              }
    329          }
   \                     ??timer_list_remove_6: (+1)
   \                     ??timer_list_remove_3: (+1)
   \   000000BA   0xBD70             POP      {R4-R6,PC}       ;; return
    330          
    331          
    332          /**@brief Function for scheduling a check for timeouts by generating a RTC1 interrupt.
    333           */

   \                                 In section .text, align 2, keep-with-next
    334          static void timer_timeouts_check_sched(void)
    335          {
   \                     timer_timeouts_check_sched: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    336              NVIC_SetPendingIRQ(RTC1_IRQn);
   \   00000002   0x2011             MOVS     R0,#+17
   \   00000004   0x.... 0x....      BL       NVIC_SetPendingIRQ
    337          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    338          
    339          
    340          /**@brief Function for scheduling a timer list update by generating a SWI0 interrupt.
    341           */

   \                                 In section .text, align 2, keep-with-next
    342          static void timer_list_handler_sched(void)
    343          {
   \                     timer_list_handler_sched: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    344              NVIC_SetPendingIRQ(SWI0_IRQn);
   \   00000002   0x2014             MOVS     R0,#+20
   \   00000004   0x.... 0x....      BL       NVIC_SetPendingIRQ
    345          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    346          
    347          
    348          /**@brief Function for executing an application timeout handler, either by calling it directly, or
    349           *        by passing an event to the @ref app_scheduler.
    350           *
    351           * @param[in]  p_timer   Pointer to expired timer.
    352           */

   \                                 In section .text, align 2, keep-with-next
    353          static void timeout_handler_exec(timer_node_t * p_timer)
    354          {
   \                     timeout_handler_exec: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    355              if (m_evt_schedule_func != NULL)
   \   00000004   0x....             LDR      R0,??DataTable18_1
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00E             BEQ      ??timeout_handler_exec_0
    356              {
    357                  uint32_t err_code = m_evt_schedule_func(p_timer->p_timeout_handler, p_timer->p_context);
   \   0000000C   0x69E1             LDR      R1,[R4, #+28]
   \   0000000E   0x69A0             LDR      R0,[R4, #+24]
   \   00000010   0x....             LDR      R2,??DataTable18_1
   \   00000012   0x6812             LDR      R2,[R2, #+0]
   \   00000014   0x4790             BLX      R2
   \   00000016   0x0005             MOVS     R5,R0
    358                  APP_ERROR_CHECK(err_code);
   \   00000018   0x002E             MOVS     R6,R5
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD004             BEQ      ??timeout_handler_exec_1
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x0030             MOVS     R0,R6
   \   00000024   0x.... 0x....      BL       app_error_handler
   \                     ??timeout_handler_exec_1: (+1)
   \   00000028   0xE002             B        ??timeout_handler_exec_2
    359              }
    360              else
    361              {
    362                  p_timer->p_timeout_handler(p_timer->p_context);
   \                     ??timeout_handler_exec_0: (+1)
   \   0000002A   0x69E0             LDR      R0,[R4, #+28]
   \   0000002C   0x69A1             LDR      R1,[R4, #+24]
   \   0000002E   0x4788             BLX      R1
    363              }
    364          }
   \                     ??timeout_handler_exec_2: (+1)
   \   00000030   0xBD70             POP      {R4-R6,PC}       ;; return
    365          
    366          
    367          /**@brief Function for checking for expired timers.
    368           */

   \                                 In section .text, align 2, keep-with-next
    369          static void timer_timeouts_check(void)
    370          {
   \                     timer_timeouts_check: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    371              // Handle expired of timer 
    372              if (m_timer_id_head != TIMER_NULL)
   \   00000002   0x....             LDR      R0,??DataTable16_3
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD03C             BEQ      ??timer_timeouts_check_0
    373              {
    374                  app_timer_id_t  timer_id;
    375                  uint32_t        ticks_elapsed;
    376                  uint32_t        ticks_expired;
    377          
    378                  // Initialize actual elapsed ticks being consumed to 0.
    379                  ticks_expired = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x0005             MOVS     R5,R0
    380          
    381                  // ticks_elapsed is collected here, job will use it.
    382                  ticks_elapsed = ticks_diff_get(rtc1_counter_get(), m_ticks_latest);
   \   00000012   0x.... 0x....      BL       rtc1_counter_get
   \   00000016   0x....             LDR      R1,??DataTable15_6
   \   00000018   0x6809             LDR      R1,[R1, #+0]
   \   0000001A   0x.... 0x....      BL       ticks_diff_get
   \   0000001E   0x0004             MOVS     R4,R0
    383          
    384                  // Auto variable containing the head of timers expiring.
    385                  timer_id = m_timer_id_head;
   \   00000020   0x....             LDR      R0,??DataTable16_3
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x0007             MOVS     R7,R0
    386          
    387                  // Expire all timers within ticks_elapsed and collect ticks_expired.
    388                  while (timer_id != TIMER_NULL)
   \                     ??timer_timeouts_check_1: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x43C0             MVNS     R0,R0            ;; #-1
   \   0000002A   0x4287             CMP      R7,R0
   \   0000002C   0xD012             BEQ      ??timer_timeouts_check_2
    389                  {
    390                      timer_node_t * p_timer;
    391          
    392                      // Auto variable for current timer node 
    393                      p_timer = &mp_nodes[timer_id];
   \   0000002E   0x....             LDR      R0,??DataTable16_2
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x2124             MOVS     R1,#+36
   \   00000034   0x4379             MULS     R1,R7,R1
   \   00000036   0x1840             ADDS     R0,R0,R1
   \   00000038   0x0006             MOVS     R6,R0
    394          
    395                      // Do nothing if timer did not expire.
    396                      if (ticks_elapsed < p_timer->ticks_to_expire)
   \   0000003A   0x6870             LDR      R0,[R6, #+4]
   \   0000003C   0x4284             CMP      R4,R0
   \   0000003E   0xD309             BCC      ??timer_timeouts_check_2
    397                      {
    398                          break;
    399                      }
    400          
    401                      // Decrement ticks_elapsed and collect expired ticks.
    402                      ticks_elapsed -= p_timer->ticks_to_expire;
   \                     ??timer_timeouts_check_3: (+1)
   \   00000040   0x6870             LDR      R0,[R6, #+4]
   \   00000042   0x1A24             SUBS     R4,R4,R0
    403                      ticks_expired += p_timer->ticks_to_expire;
   \   00000044   0x6870             LDR      R0,[R6, #+4]
   \   00000046   0x182D             ADDS     R5,R5,R0
    404          
    405                      // Move to next timer.
    406                      timer_id = p_timer->next;
   \   00000048   0x6A30             LDR      R0,[R6, #+32]
   \   0000004A   0x0007             MOVS     R7,R0
    407          
    408                      // Execute Task.
    409                      timeout_handler_exec(p_timer);
   \   0000004C   0x0030             MOVS     R0,R6
   \   0000004E   0x.... 0x....      BL       timeout_handler_exec
   \   00000052   0xE7E8             B        ??timer_timeouts_check_1
    410                  }
    411          
    412                  // Prepare to queue the ticks expired in the m_ticks_elapsed queue.
    413                  if (m_ticks_elapsed_q_read_ind == m_ticks_elapsed_q_write_ind)
   \                     ??timer_timeouts_check_2: (+1)
   \   00000054   0x....             LDR      R0,??DataTable18_2
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0x....             LDR      R1,??DataTable19
   \   0000005A   0x7809             LDRB     R1,[R1, #+0]
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD10B             BNE      ??timer_timeouts_check_4
    414                  {
    415                      // The read index of the queue is equal to the write index. This means the new
    416                      // value of ticks_expired should be stored at a new location in the m_ticks_elapsed
    417                      // queue (which is implemented as a double buffer).
    418          
    419                      // Check if there will be a queue overflow.
    420                      if (++m_ticks_elapsed_q_write_ind == CONTEXT_QUEUE_SIZE_MAX)
   \   00000060   0x....             LDR      R0,??DataTable19
   \   00000062   0x7800             LDRB     R0,[R0, #+0]
   \   00000064   0x1C40             ADDS     R0,R0,#+1
   \   00000066   0x....             LDR      R1,??DataTable19
   \   00000068   0x7008             STRB     R0,[R1, #+0]
   \   0000006A   0x....             LDR      R0,??DataTable19
   \   0000006C   0x7800             LDRB     R0,[R0, #+0]
   \   0000006E   0x2802             CMP      R0,#+2
   \   00000070   0xD102             BNE      ??timer_timeouts_check_4
    421                      {
    422                          // There will be a queue overflow. Hence the write index should point to the start
    423                          // of the queue.
    424                          m_ticks_elapsed_q_write_ind = 0;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x....             LDR      R1,??DataTable19
   \   00000076   0x7008             STRB     R0,[R1, #+0]
    425                      }
    426                  }
    427          
    428                  // Queue the ticks expired.
    429                  m_ticks_elapsed[m_ticks_elapsed_q_write_ind] = ticks_expired;
   \                     ??timer_timeouts_check_4: (+1)
   \   00000078   0x....             LDR      R0,??DataTable19_1
   \   0000007A   0x....             LDR      R1,??DataTable19
   \   0000007C   0x7809             LDRB     R1,[R1, #+0]
   \   0000007E   0x2204             MOVS     R2,#+4
   \   00000080   0x4351             MULS     R1,R2,R1
   \   00000082   0x5045             STR      R5,[R0, R1]
    430          
    431                  timer_list_handler_sched();
   \   00000084   0x.... 0x....      BL       timer_list_handler_sched
    432              }
    433          }
   \                     ??timer_timeouts_check_0: (+1)
   \   00000088   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    434          
    435          
    436          /**@brief Function for acquiring the number of ticks elapsed.
    437           *
    438           * @param[out] p_ticks_elapsed   Number of ticks elapsed.
    439           *
    440           * @return     TRUE if elapsed ticks was read from queue, FALSE otherwise.
    441           */

   \                                 In section .text, align 2, keep-with-next
    442          static bool elapsed_ticks_acquire(uint32_t * p_ticks_elapsed)
    443          {
   \                     elapsed_ticks_acquire: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0001             MOVS     R1,R0
    444              // Pick the elapsed value from queue.
    445              if (m_ticks_elapsed_q_read_ind != m_ticks_elapsed_q_write_ind)
   \   00000004   0x....             LDR      R0,??DataTable18_2
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x....             LDR      R2,??DataTable19
   \   0000000A   0x7812             LDRB     R2,[R2, #+0]
   \   0000000C   0x4290             CMP      R0,R2
   \   0000000E   0xD020             BEQ      ??elapsed_ticks_acquire_0
    446              {
    447                  // Dequeue elapsed value.
    448                  m_ticks_elapsed_q_read_ind++;
   \   00000010   0x....             LDR      R0,??DataTable18_2
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0x....             LDR      R2,??DataTable18_2
   \   00000018   0x7010             STRB     R0,[R2, #+0]
    449                  if (m_ticks_elapsed_q_read_ind == CONTEXT_QUEUE_SIZE_MAX)
   \   0000001A   0x....             LDR      R0,??DataTable18_2
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2802             CMP      R0,#+2
   \   00000020   0xD102             BNE      ??elapsed_ticks_acquire_1
    450                  {
    451                      m_ticks_elapsed_q_read_ind = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x....             LDR      R2,??DataTable18_2
   \   00000026   0x7010             STRB     R0,[R2, #+0]
    452                  }
    453          
    454                  *p_ticks_elapsed = m_ticks_elapsed[m_ticks_elapsed_q_read_ind];
   \                     ??elapsed_ticks_acquire_1: (+1)
   \   00000028   0x....             LDR      R0,??DataTable19_1
   \   0000002A   0x....             LDR      R2,??DataTable18_2
   \   0000002C   0x7812             LDRB     R2,[R2, #+0]
   \   0000002E   0x2304             MOVS     R3,#+4
   \   00000030   0x435A             MULS     R2,R3,R2
   \   00000032   0x5880             LDR      R0,[R0, R2]
   \   00000034   0x6008             STR      R0,[R1, #+0]
    455          
    456                  m_ticks_latest += *p_ticks_elapsed;
   \   00000036   0x....             LDR      R0,??DataTable20
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x680A             LDR      R2,[R1, #+0]
   \   0000003C   0x1880             ADDS     R0,R0,R2
   \   0000003E   0x....             LDR      R2,??DataTable20
   \   00000040   0x6010             STR      R0,[R2, #+0]
    457                  m_ticks_latest &= MAX_RTC_COUNTER_VAL;
   \   00000042   0x....             LDR      R0,??DataTable20
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x0200             LSLS     R0,R0,#+8        ;; ZeroExtS R0,R0,#+8,#+8
   \   00000048   0x0A00             LSRS     R0,R0,#+8
   \   0000004A   0x....             LDR      R2,??DataTable20
   \   0000004C   0x6010             STR      R0,[R2, #+0]
    458          
    459                  return true;
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xE002             B        ??elapsed_ticks_acquire_2
    460              }
    461              else
    462              {
    463                  // No elapsed value in queue.
    464                  *p_ticks_elapsed = 0;
   \                     ??elapsed_ticks_acquire_0: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x6008             STR      R0,[R1, #+0]
    465                  return false;
   \   00000056   0x2000             MOVS     R0,#+0
   \                     ??elapsed_ticks_acquire_2: (+1)
   \   00000058   0xBD00             POP      {PC}             ;; return
    466              }
    467          }
    468          
    469          
    470          /**@brief Function for handling the timer list deletions.
    471           *
    472           * @return     TRUE if Capture Compare register must be updated, FALSE otherwise.
    473           */

   \                                 In section .text, align 2, keep-with-next
    474          static bool list_deletions_handler(void)
    475          {
   \                     list_deletions_handler: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    476              app_timer_id_t timer_id_old_head;
    477              uint8_t        user_id;
    478          
    479              // Remember the old head, so as to decide if new compare needs to be set.
    480              timer_id_old_head = m_timer_id_head;
   \   00000004   0x....             LDR      R0,??DataTable20_1
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x9001             STR      R0,[SP, #+4]
    481          
    482              user_id = m_user_array_size;
   \   0000000A   0x....             LDR      R0,??DataTable20_2
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x0004             MOVS     R4,R0
    483              while (user_id--)
   \                     ??list_deletions_handler_0: (+1)
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x1E44             SUBS     R4,R0,#+1
   \   00000014   0xB2C0             UXTB     R0,R0
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD043             BEQ      ??list_deletions_handler_1
    484              {
    485                  timer_user_t * p_user         = &mp_users[user_id];
   \   0000001A   0x....             LDR      R0,??DataTable20_3
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xB2E4             UXTB     R4,R4
   \   00000020   0x2108             MOVS     R1,#+8
   \   00000022   0x4361             MULS     R1,R4,R1
   \   00000024   0x1847             ADDS     R7,R0,R1
    486                  uint8_t        user_ops_first = p_user->first;
   \   00000026   0x783D             LDRB     R5,[R7, #+0]
    487                  
    488                  while (user_ops_first != p_user->last)
   \                     ??list_deletions_handler_2: (+1)
   \   00000028   0x7878             LDRB     R0,[R7, #+1]
   \   0000002A   0xB2ED             UXTB     R5,R5
   \   0000002C   0x4285             CMP      R5,R0
   \   0000002E   0xD0EF             BEQ      ??list_deletions_handler_0
    489                  {
    490                      timer_node_t *    p_timer;
    491                      timer_user_op_t * p_user_op = &p_user->p_user_op_queue[user_ops_first];
   \   00000030   0x6878             LDR      R0,[R7, #+4]
   \   00000032   0xB2ED             UXTB     R5,R5
   \   00000034   0x2118             MOVS     R1,#+24
   \   00000036   0x4369             MULS     R1,R5,R1
   \   00000038   0x1846             ADDS     R6,R0,R1
    492          
    493                      // Traverse to next operation in queue.
    494                      user_ops_first++;
   \   0000003A   0x1C6D             ADDS     R5,R5,#+1
    495                      if (user_ops_first == p_user->user_op_queue_size)
   \   0000003C   0x78B8             LDRB     R0,[R7, #+2]
   \   0000003E   0xB2ED             UXTB     R5,R5
   \   00000040   0x4285             CMP      R5,R0
   \   00000042   0xD101             BNE      ??list_deletions_handler_3
    496                      {
    497                          user_ops_first = 0;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x0005             MOVS     R5,R0
    498                      }
    499          
    500                      switch (p_user_op->op_type)
   \                     ??list_deletions_handler_3: (+1)
   \   00000048   0x7830             LDRB     R0,[R6, #+0]
   \   0000004A   0x2802             CMP      R0,#+2
   \   0000004C   0xD002             BEQ      ??list_deletions_handler_4
   \   0000004E   0x2803             CMP      R0,#+3
   \   00000050   0xD012             BEQ      ??list_deletions_handler_5
   \   00000052   0xE025             B        ??list_deletions_handler_6
    501                      {
    502                          case TIMER_USER_OP_TYPE_STOP:
    503                              // Delete node if timer is running.
    504                              p_timer = &mp_nodes[p_user_op->timer_id];
   \                     ??list_deletions_handler_4: (+1)
   \   00000054   0x....             LDR      R0,??DataTable18_3
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x6871             LDR      R1,[R6, #+4]
   \   0000005A   0x2224             MOVS     R2,#+36
   \   0000005C   0x4351             MULS     R1,R2,R1
   \   0000005E   0x1840             ADDS     R0,R0,R1
   \   00000060   0x9000             STR      R0,[SP, #+0]
    505                              if (p_timer->is_running)
   \   00000062   0x9800             LDR      R0,[SP, #+0]
   \   00000064   0x7D00             LDRB     R0,[R0, #+20]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD005             BEQ      ??list_deletions_handler_7
    506                              {
    507                                  timer_list_remove(p_user_op->timer_id);
   \   0000006A   0x6870             LDR      R0,[R6, #+4]
   \   0000006C   0x.... 0x....      BL       timer_list_remove
    508                                  p_timer->is_running = false;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x9900             LDR      R1,[SP, #+0]
   \   00000074   0x7508             STRB     R0,[R1, #+20]
    509                              }
    510                              break;
   \                     ??list_deletions_handler_7: (+1)
   \   00000076   0xE7D7             B        ??list_deletions_handler_2
    511                              
    512                          case TIMER_USER_OP_TYPE_STOP_ALL:
    513                              // Delete list of running timers, and mark all timers as not running.
    514                              while (m_timer_id_head != TIMER_NULL)
   \                     ??list_deletions_handler_5: (+1)
   \   00000078   0x....             LDR      R0,??DataTable20_1
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x2100             MOVS     R1,#+0
   \   0000007E   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000080   0x4288             CMP      R0,R1
   \   00000082   0xD00C             BEQ      ??list_deletions_handler_8
    515                              {
    516                                  timer_node_t * p_head = &mp_nodes[m_timer_id_head];
   \   00000084   0x....             LDR      R0,??DataTable18_3
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x....             LDR      R1,??DataTable20_1
   \   0000008A   0x6809             LDR      R1,[R1, #+0]
   \   0000008C   0x2224             MOVS     R2,#+36
   \   0000008E   0x4351             MULS     R1,R2,R1
   \   00000090   0x1840             ADDS     R0,R0,R1
    517          
    518                                  p_head->is_running = false;
   \   00000092   0x2100             MOVS     R1,#+0
   \   00000094   0x7501             STRB     R1,[R0, #+20]
    519                                  m_timer_id_head    = p_head->next;
   \   00000096   0x6A00             LDR      R0,[R0, #+32]
   \   00000098   0x....             LDR      R1,??DataTable20_1
   \   0000009A   0x6008             STR      R0,[R1, #+0]
   \   0000009C   0xE7EC             B        ??list_deletions_handler_5
    520                              }
    521                              break;
   \                     ??list_deletions_handler_8: (+1)
   \   0000009E   0xE7C3             B        ??list_deletions_handler_2
    522                              
    523                          default:
    524                              // No implementation needed.
    525                              break;
   \                     ??list_deletions_handler_6: (+1)
   \   000000A0   0xE7C2             B        ??list_deletions_handler_2
    526                      }
    527                  }
    528              }
    529          
    530              // Detect change in head of the list.
    531              return (m_timer_id_head != timer_id_old_head);
   \                     ??list_deletions_handler_1: (+1)
   \   000000A2   0x....             LDR      R0,??DataTable20_1
   \   000000A4   0x6800             LDR      R0,[R0, #+0]
   \   000000A6   0x9901             LDR      R1,[SP, #+4]
   \   000000A8   0x4288             CMP      R0,R1
   \   000000AA   0xD001             BEQ      ??list_deletions_handler_9
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0xE000             B        ??list_deletions_handler_10
   \                     ??list_deletions_handler_9: (+1)
   \   000000B0   0x2000             MOVS     R0,#+0
   \                     ??list_deletions_handler_10: (+1)
   \   000000B2   0xB2C0             UXTB     R0,R0
   \   000000B4   0xBDFE             POP      {R1-R7,PC}       ;; return
    532          }
    533          
    534          
    535          /**@brief Function for updating the timer list for expired timers.
    536           *
    537           * @param[in]  ticks_elapsed         Number of elapsed ticks.
    538           * @param[in]  ticks_previous        Previous known value of the RTC counter.
    539           * @param[out] p_restart_list_head   List of repeating timers to be restarted.
    540           */

   \                                 In section .text, align 2, keep-with-next
    541          static void expired_timers_handler(uint32_t         ticks_elapsed,
    542                                             uint32_t         ticks_previous,
    543                                             app_timer_id_t * p_restart_list_head)
    544          {
   \                     expired_timers_handler: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    545              uint32_t ticks_expired = 0;
   \   00000002   0x2300             MOVS     R3,#+0
    546          
    547              while (m_timer_id_head != TIMER_NULL)
   \                     ??expired_timers_handler_0: (+1)
   \   00000004   0x....             LDR      R4,??DataTable20_1
   \   00000006   0x6824             LDR      R4,[R4, #+0]
   \   00000008   0x2500             MOVS     R5,#+0
   \   0000000A   0x43ED             MVNS     R5,R5            ;; #-1
   \   0000000C   0x42AC             CMP      R4,R5
   \   0000000E   0xD02B             BEQ      ??expired_timers_handler_1
    548              {
    549                  timer_node_t * p_timer;
    550                  app_timer_id_t id_expired;
    551          
    552                  // Auto variable for current timer node.
    553                  p_timer = &mp_nodes[m_timer_id_head];
   \   00000010   0x....             LDR      R6,??DataTable18_3
   \   00000012   0x6836             LDR      R6,[R6, #+0]
   \   00000014   0x46B4             MOV      R12,R6
   \   00000016   0x....             LDR      R6,??DataTable20_1
   \   00000018   0x6837             LDR      R7,[R6, #+0]
   \   0000001A   0x2624             MOVS     R6,#+36
   \   0000001C   0x4377             MULS     R7,R6,R7
   \   0000001E   0x4666             MOV      R6,R12
   \   00000020   0x19F6             ADDS     R6,R6,R7
   \   00000022   0x0034             MOVS     R4,R6
    554          
    555                  // Do nothing if timer did not expire 
    556                  if (ticks_elapsed < p_timer->ticks_to_expire)
   \   00000024   0x6866             LDR      R6,[R4, #+4]
   \   00000026   0x42B0             CMP      R0,R6
   \   00000028   0xD203             BCS      ??expired_timers_handler_2
    557                  {
    558                      p_timer->ticks_to_expire -= ticks_elapsed;
   \   0000002A   0x6866             LDR      R6,[R4, #+4]
   \   0000002C   0x1A36             SUBS     R6,R6,R0
   \   0000002E   0x6066             STR      R6,[R4, #+4]
    559                      break;
   \   00000030   0xE01A             B        ??expired_timers_handler_1
    560                  }
    561          
    562                  // Decrement ticks_elapsed and collect expired ticks.
    563                  ticks_elapsed -= p_timer->ticks_to_expire;
   \                     ??expired_timers_handler_2: (+1)
   \   00000032   0x6866             LDR      R6,[R4, #+4]
   \   00000034   0x1B80             SUBS     R0,R0,R6
    564                  ticks_expired += p_timer->ticks_to_expire;
   \   00000036   0x6866             LDR      R6,[R4, #+4]
   \   00000038   0x199B             ADDS     R3,R3,R6
    565          
    566                  // Timer expired, set ticks_to_expire zero.
    567                  p_timer->ticks_to_expire = 0;
   \   0000003A   0x2600             MOVS     R6,#+0
   \   0000003C   0x6066             STR      R6,[R4, #+4]
    568                  p_timer->is_running      = false;
   \   0000003E   0x2600             MOVS     R6,#+0
   \   00000040   0x7526             STRB     R6,[R4, #+20]
    569          
    570                  // Remove the expired timer from head.
    571                  id_expired      = m_timer_id_head;
   \   00000042   0x....             LDR      R6,??DataTable20_1
   \   00000044   0x6836             LDR      R6,[R6, #+0]
   \   00000046   0x0035             MOVS     R5,R6
    572                  m_timer_id_head = p_timer->next;
   \   00000048   0x6A26             LDR      R6,[R4, #+32]
   \   0000004A   0x....             LDR      R7,??DataTable20_1
   \   0000004C   0x603E             STR      R6,[R7, #+0]
    573          
    574                  // Timer will be restarted if periodic.
    575                  if (p_timer->ticks_periodic_interval != 0)
   \   0000004E   0x6926             LDR      R6,[R4, #+16]
   \   00000050   0x2E00             CMP      R6,#+0
   \   00000052   0xD0D7             BEQ      ??expired_timers_handler_0
    576                  {
    577                      p_timer->ticks_at_start       = (ticks_previous + ticks_expired) & MAX_RTC_COUNTER_VAL;
   \   00000054   0x18CE             ADDS     R6,R1,R3
   \   00000056   0x0236             LSLS     R6,R6,#+8        ;; ZeroExtS R6,R6,#+8,#+8
   \   00000058   0x0A36             LSRS     R6,R6,#+8
   \   0000005A   0x60A6             STR      R6,[R4, #+8]
    578                      p_timer->ticks_first_interval = p_timer->ticks_periodic_interval;
   \   0000005C   0x6926             LDR      R6,[R4, #+16]
   \   0000005E   0x60E6             STR      R6,[R4, #+12]
    579                      p_timer->next                 = *p_restart_list_head;
   \   00000060   0x6816             LDR      R6,[R2, #+0]
   \   00000062   0x6226             STR      R6,[R4, #+32]
    580                      *p_restart_list_head          = id_expired;
   \   00000064   0x6015             STR      R5,[R2, #+0]
   \   00000066   0xE7CD             B        ??expired_timers_handler_0
    581                  }
    582              }
    583          }
   \                     ??expired_timers_handler_1: (+1)
   \   00000068   0xBDF0             POP      {R4-R7,PC}       ;; return
    584          
    585          
    586          /**@brief Function for handling timer list insertions.
    587           *
    588           * @param[in]  p_restart_list_head   List of repeating timers to be restarted.
    589           *
    590           * @return     TRUE if Capture Compare register must be updated, FALSE otherwise.
    591           */

   \                                 In section .text, align 2, keep-with-next
    592          static bool list_insertions_handler(app_timer_id_t restart_list_head)
    593          {
   \                     list_insertions_handler: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x0006             MOVS     R6,R0
    594              app_timer_id_t timer_id_old_head;
    595              uint8_t        user_id;
    596          
    597              // Remember the old head, so as to decide if new compare needs to be set.
    598              timer_id_old_head = m_timer_id_head;
   \   00000004   0x....             LDR      R0,??DataTable20_1
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x9002             STR      R0,[SP, #+8]
    599          
    600              user_id = m_user_array_size;
   \   0000000A   0x....             LDR      R0,??DataTable20_2
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x0007             MOVS     R7,R0
    601              while (user_id--)
   \                     ??list_insertions_handler_0: (+1)
   \   00000010   0x0038             MOVS     R0,R7
   \   00000012   0x1E47             SUBS     R7,R0,#+1
   \   00000014   0xB2C0             UXTB     R0,R0
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD078             BEQ      ??list_insertions_handler_1
    602              {
    603                  timer_user_t * p_user = &mp_users[user_id];
   \   0000001A   0x....             LDR      R0,??DataTable20_3
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xB2FF             UXTB     R7,R7
   \   00000020   0x2108             MOVS     R1,#+8
   \   00000022   0x4379             MULS     R1,R7,R1
   \   00000024   0x1844             ADDS     R4,R0,R1
    604          
    605                  // Handle insertions of timers.
    606                  while ((restart_list_head != TIMER_NULL) || (p_user->first != p_user->last))
   \                     ??list_insertions_handler_2: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x43C0             MVNS     R0,R0            ;; #-1
   \   0000002A   0x4286             CMP      R6,R0
   \   0000002C   0xD103             BNE      ??list_insertions_handler_3
   \   0000002E   0x7820             LDRB     R0,[R4, #+0]
   \   00000030   0x7861             LDRB     R1,[R4, #+1]
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD0EC             BEQ      ??list_insertions_handler_0
    607                  {
    608                      app_timer_id_t id_start;
    609                      timer_node_t * p_timer;
    610          
    611                      if (restart_list_head != TIMER_NULL)
   \                     ??list_insertions_handler_3: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x43C0             MVNS     R0,R0            ;; #-1
   \   0000003A   0x4286             CMP      R6,R0
   \   0000003C   0xD00A             BEQ      ??list_insertions_handler_4
    612                      {
    613                          id_start          = restart_list_head;
   \   0000003E   0x9600             STR      R6,[SP, #+0]
    614                          p_timer           = &mp_nodes[id_start];
   \   00000040   0x....             LDR      R0,??DataTable24
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x9900             LDR      R1,[SP, #+0]
   \   00000046   0x2224             MOVS     R2,#+36
   \   00000048   0x4351             MULS     R1,R2,R1
   \   0000004A   0x1840             ADDS     R0,R0,R1
   \   0000004C   0x0005             MOVS     R5,R0
    615                          restart_list_head = p_timer->next;
   \   0000004E   0x6A28             LDR      R0,[R5, #+32]
   \   00000050   0x0006             MOVS     R6,R0
   \   00000052   0xE02B             B        ??list_insertions_handler_5
    616                      }
    617                      else
    618                      {
    619                          timer_user_op_t * p_user_op = &p_user->p_user_op_queue[p_user->first];
   \                     ??list_insertions_handler_4: (+1)
   \   00000054   0x6860             LDR      R0,[R4, #+4]
   \   00000056   0x7821             LDRB     R1,[R4, #+0]
   \   00000058   0x2218             MOVS     R2,#+24
   \   0000005A   0x4351             MULS     R1,R2,R1
   \   0000005C   0x1840             ADDS     R0,R0,R1
    620          
    621                          p_user->first++;
   \   0000005E   0x7821             LDRB     R1,[R4, #+0]
   \   00000060   0x1C49             ADDS     R1,R1,#+1
   \   00000062   0x7021             STRB     R1,[R4, #+0]
    622                          if (p_user->first == p_user->user_op_queue_size)
   \   00000064   0x7821             LDRB     R1,[R4, #+0]
   \   00000066   0x78A2             LDRB     R2,[R4, #+2]
   \   00000068   0x4291             CMP      R1,R2
   \   0000006A   0xD101             BNE      ??list_insertions_handler_6
    623                          {
    624                              p_user->first = 0;
   \   0000006C   0x2100             MOVS     R1,#+0
   \   0000006E   0x7021             STRB     R1,[R4, #+0]
    625                          }
    626          
    627                          id_start = p_user_op->timer_id;
   \                     ??list_insertions_handler_6: (+1)
   \   00000070   0x6841             LDR      R1,[R0, #+4]
   \   00000072   0x9100             STR      R1,[SP, #+0]
    628                          p_timer  = &mp_nodes[id_start];
   \   00000074   0x....             LDR      R1,??DataTable24
   \   00000076   0x6809             LDR      R1,[R1, #+0]
   \   00000078   0x9A00             LDR      R2,[SP, #+0]
   \   0000007A   0x2324             MOVS     R3,#+36
   \   0000007C   0x435A             MULS     R2,R3,R2
   \   0000007E   0x1889             ADDS     R1,R1,R2
   \   00000080   0x000D             MOVS     R5,R1
    629          
    630                          if ((p_user_op->op_type != TIMER_USER_OP_TYPE_START) || p_timer->is_running)
   \   00000082   0x7801             LDRB     R1,[R0, #+0]
   \   00000084   0x2901             CMP      R1,#+1
   \   00000086   0xD102             BNE      ??list_insertions_handler_7
   \   00000088   0x7D29             LDRB     R1,[R5, #+20]
   \   0000008A   0x2900             CMP      R1,#+0
   \   0000008C   0xD000             BEQ      ??list_insertions_handler_8
    631                          {
    632                              continue;
   \                     ??list_insertions_handler_7: (+1)
   \   0000008E   0xE7CA             B        ??list_insertions_handler_2
    633                          }
    634          
    635                          p_timer->ticks_at_start          = p_user_op->params.start.ticks_at_start;
   \                     ??list_insertions_handler_8: (+1)
   \   00000090   0x6881             LDR      R1,[R0, #+8]
   \   00000092   0x60A9             STR      R1,[R5, #+8]
    636                          p_timer->ticks_first_interval    = p_user_op->params.start.ticks_first_interval;
   \   00000094   0x68C1             LDR      R1,[R0, #+12]
   \   00000096   0x60E9             STR      R1,[R5, #+12]
    637                          p_timer->ticks_periodic_interval = p_user_op->params.start.ticks_periodic_interval;
   \   00000098   0x6901             LDR      R1,[R0, #+16]
   \   0000009A   0x6129             STR      R1,[R5, #+16]
    638                          p_timer->p_context               = p_user_op->params.start.p_context;
   \   0000009C   0x6941             LDR      R1,[R0, #+20]
   \   0000009E   0x61E9             STR      R1,[R5, #+28]
    639          
    640                          if (m_rtc1_reset)
   \   000000A0   0x....             LDR      R1,??DataTable25
   \   000000A2   0x7809             LDRB     R1,[R1, #+0]
   \   000000A4   0x2900             CMP      R1,#+0
   \   000000A6   0xD001             BEQ      ??list_insertions_handler_5
    641                          {
    642                              p_timer->ticks_at_start = 0;
   \   000000A8   0x2100             MOVS     R1,#+0
   \   000000AA   0x60A9             STR      R1,[R5, #+8]
    643                          }
    644                      }
    645          
    646                      // Prepare the node to be inserted.
    647                      if (
    648                           ((p_timer->ticks_at_start - m_ticks_latest) & MAX_RTC_COUNTER_VAL)
    649                           <
    650                           (MAX_RTC_COUNTER_VAL / 2)
    651                          )
   \                     ??list_insertions_handler_5: (+1)
   \   000000AC   0x68A8             LDR      R0,[R5, #+8]
   \   000000AE   0x....             LDR      R1,??DataTable20
   \   000000B0   0x6809             LDR      R1,[R1, #+0]
   \   000000B2   0x1A40             SUBS     R0,R0,R1
   \   000000B4   0x0200             LSLS     R0,R0,#+8        ;; ZeroExtS R0,R0,#+8,#+8
   \   000000B6   0x0A00             LSRS     R0,R0,#+8
   \   000000B8   0x....             LDR      R1,??DataTable25_1  ;; 0x7fffff
   \   000000BA   0x4288             CMP      R0,R1
   \   000000BC   0xD208             BCS      ??list_insertions_handler_9
    652                      {
    653                          p_timer->ticks_to_expire = ticks_diff_get(p_timer->ticks_at_start, m_ticks_latest) + 
    654                                                     p_timer->ticks_first_interval;
   \   000000BE   0x....             LDR      R0,??DataTable20
   \   000000C0   0x6801             LDR      R1,[R0, #+0]
   \   000000C2   0x68A8             LDR      R0,[R5, #+8]
   \   000000C4   0x.... 0x....      BL       ticks_diff_get
   \   000000C8   0x68E9             LDR      R1,[R5, #+12]
   \   000000CA   0x1840             ADDS     R0,R0,R1
   \   000000CC   0x6068             STR      R0,[R5, #+4]
   \   000000CE   0xE010             B        ??list_insertions_handler_10
    655                      }
    656                      else
    657                      {
    658                          uint32_t delta_current_start;
    659          
    660                          delta_current_start = ticks_diff_get(m_ticks_latest, p_timer->ticks_at_start);
   \                     ??list_insertions_handler_9: (+1)
   \   000000D0   0x68A9             LDR      R1,[R5, #+8]
   \   000000D2   0x....             LDR      R0,??DataTable20
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0x.... 0x....      BL       ticks_diff_get
   \   000000DA   0x9001             STR      R0,[SP, #+4]
    661                          if (p_timer->ticks_first_interval > delta_current_start)
   \   000000DC   0x9801             LDR      R0,[SP, #+4]
   \   000000DE   0x68E9             LDR      R1,[R5, #+12]
   \   000000E0   0x4288             CMP      R0,R1
   \   000000E2   0xD204             BCS      ??list_insertions_handler_11
    662                          {
    663                              p_timer->ticks_to_expire = p_timer->ticks_first_interval - delta_current_start;
   \   000000E4   0x68E8             LDR      R0,[R5, #+12]
   \   000000E6   0x9901             LDR      R1,[SP, #+4]
   \   000000E8   0x1A40             SUBS     R0,R0,R1
   \   000000EA   0x6068             STR      R0,[R5, #+4]
   \   000000EC   0xE001             B        ??list_insertions_handler_10
    664                          }
    665                          else
    666                          {
    667                              p_timer->ticks_to_expire = 0;
   \                     ??list_insertions_handler_11: (+1)
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x6068             STR      R0,[R5, #+4]
    668                          }
    669                      }
    670          
    671                      p_timer->ticks_at_start       = 0;
   \                     ??list_insertions_handler_10: (+1)
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0x60A8             STR      R0,[R5, #+8]
    672                      p_timer->ticks_first_interval = 0;
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0x60E8             STR      R0,[R5, #+12]
    673                      p_timer->is_running           = true;
   \   000000FA   0x2001             MOVS     R0,#+1
   \   000000FC   0x7528             STRB     R0,[R5, #+20]
    674                      p_timer->next                 = TIMER_NULL;
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000102   0x6228             STR      R0,[R5, #+32]
    675          
    676                      // Insert into list 
    677                      timer_list_insert(id_start);
   \   00000104   0x9800             LDR      R0,[SP, #+0]
   \   00000106   0x.... 0x....      BL       timer_list_insert
   \   0000010A   0xE78C             B        ??list_insertions_handler_2
    678                  }
    679              }
    680              
    681              return (m_timer_id_head != timer_id_old_head);
   \                     ??list_insertions_handler_1: (+1)
   \   0000010C   0x....             LDR      R0,??DataTable20_1
   \   0000010E   0x6800             LDR      R0,[R0, #+0]
   \   00000110   0x9902             LDR      R1,[SP, #+8]
   \   00000112   0x4288             CMP      R0,R1
   \   00000114   0xD001             BEQ      ??list_insertions_handler_12
   \   00000116   0x2001             MOVS     R0,#+1
   \   00000118   0xE000             B        ??list_insertions_handler_13
   \                     ??list_insertions_handler_12: (+1)
   \   0000011A   0x2000             MOVS     R0,#+0
   \                     ??list_insertions_handler_13: (+1)
   \   0000011C   0xB2C0             UXTB     R0,R0
   \   0000011E   0xBDFE             POP      {R1-R7,PC}       ;; return
    682          }
    683          
    684          
    685          /**@brief Function for updating the Capture Compare register.
    686           */

   \                                 In section .text, align 2, keep-with-next
    687          static void compare_reg_update(app_timer_id_t timer_id_head_old)
    688          {
   \                     compare_reg_update: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    689              // Setup the timeout for timers on the head of the list 
    690              if (m_timer_id_head != TIMER_NULL)
   \   00000004   0x....             LDR      R0,??DataTable20_1
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD037             BEQ      ??compare_reg_update_0
    691              {
    692                  uint32_t ticks_to_expire = mp_nodes[m_timer_id_head].ticks_to_expire;
   \   00000010   0x....             LDR      R0,??DataTable24
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x....             LDR      R1,??DataTable20_1
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0x2224             MOVS     R2,#+36
   \   0000001A   0x4351             MULS     R1,R2,R1
   \   0000001C   0x1840             ADDS     R0,R0,R1
   \   0000001E   0x6840             LDR      R0,[R0, #+4]
   \   00000020   0x9000             STR      R0,[SP, #+0]
    693                  uint32_t pre_counter_val = rtc1_counter_get();
   \   00000022   0x.... 0x....      BL       rtc1_counter_get
   \   00000026   0x0006             MOVS     R6,R0
    694                  uint32_t cc              = m_ticks_latest;
   \   00000028   0x....             LDR      R0,??DataTable20
   \   0000002A   0x6804             LDR      R4,[R0, #+0]
    695                  uint32_t ticks_elapsed   = ticks_diff_get(pre_counter_val, cc) + RTC_COMPARE_OFFSET_MIN;
   \   0000002C   0x0021             MOVS     R1,R4
   \   0000002E   0x0030             MOVS     R0,R6
   \   00000030   0x.... 0x....      BL       ticks_diff_get
   \   00000034   0x0005             MOVS     R5,R0
   \   00000036   0x1CED             ADDS     R5,R5,#+3
    696          
    697                  if (!m_rtc1_running)
   \   00000038   0x....             LDR      R0,??DataTable26
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD101             BNE      ??compare_reg_update_1
    698                  {
    699                      // No timers were already running, start RTC
    700                      rtc1_start();
   \   00000040   0x.... 0x....      BL       rtc1_start
    701                  }
    702          
    703                  cc += (ticks_elapsed < ticks_to_expire) ? ticks_to_expire : ticks_elapsed;
   \                     ??compare_reg_update_1: (+1)
   \   00000044   0x9800             LDR      R0,[SP, #+0]
   \   00000046   0x4285             CMP      R5,R0
   \   00000048   0xD201             BCS      ??compare_reg_update_2
   \   0000004A   0x9800             LDR      R0,[SP, #+0]
   \   0000004C   0xE000             B        ??compare_reg_update_3
   \                     ??compare_reg_update_2: (+1)
   \   0000004E   0x0028             MOVS     R0,R5
   \                     ??compare_reg_update_3: (+1)
   \   00000050   0x1824             ADDS     R4,R4,R0
    704                  cc &= MAX_RTC_COUNTER_VAL;
   \   00000052   0x0224             LSLS     R4,R4,#+8        ;; ZeroExtS R4,R4,#+8,#+8
   \   00000054   0x0A24             LSRS     R4,R4,#+8
    705                  
    706                  rtc1_compare0_set(cc);
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x.... 0x....      BL       rtc1_compare0_set
    707          
    708                  uint32_t post_counter_val = rtc1_counter_get();
   \   0000005C   0x.... 0x....      BL       rtc1_counter_get
   \   00000060   0x9001             STR      R0,[SP, #+4]
    709          
    710                  if (
    711                      (ticks_diff_get(post_counter_val, pre_counter_val) + RTC_COMPARE_OFFSET_MIN)
    712                      >
    713                      ticks_diff_get(cc, pre_counter_val)
    714                     )
   \   00000062   0x0031             MOVS     R1,R6
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       ticks_diff_get
   \   0000006A   0x0007             MOVS     R7,R0
   \   0000006C   0x0031             MOVS     R1,R6
   \   0000006E   0x9801             LDR      R0,[SP, #+4]
   \   00000070   0x.... 0x....      BL       ticks_diff_get
   \   00000074   0x1CC0             ADDS     R0,R0,#+3
   \   00000076   0x4287             CMP      R7,R0
   \   00000078   0xD204             BCS      ??compare_reg_update_4
    715                  {
    716                      // When this happens the COMPARE event may not be triggered by the RTC.
    717                      // The nRF51 Series User Specification states that if the COUNTER value is N
    718                      // (i.e post_counter_val = N), writing N or N+1 to a CC register may not trigger a
    719                      // COMPARE event. Hence the RTC interrupt is forcefully pended by calling the following
    720                      // function.
    721                      timer_timeouts_check_sched();
   \   0000007A   0x.... 0x....      BL       timer_timeouts_check_sched
   \   0000007E   0xE001             B        ??compare_reg_update_4
    722                  }
    723              }
    724              else
    725              {
    726                  // No timers are running, stop RTC
    727                  rtc1_stop();
   \                     ??compare_reg_update_0: (+1)
   \   00000080   0x.... 0x....      BL       rtc1_stop
    728              }
    729          }
   \                     ??compare_reg_update_4: (+1)
   \   00000084   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    730          
    731          
    732          /**@brief Function for handling changes to the timer list.
    733           */

   \                                 In section .text, align 2, keep-with-next
    734          static void timer_list_handler(void)
    735          {
   \                     timer_list_handler: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    736              app_timer_id_t restart_list_head = TIMER_NULL;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000008   0x9000             STR      R0,[SP, #+0]
    737              uint32_t       ticks_elapsed;
    738              uint32_t       ticks_previous;
    739              bool           ticks_have_elapsed;
    740              bool           compare_update;
    741              app_timer_id_t timer_id_head_old;
    742              
    743              // Back up the previous known tick and previous list head
    744              ticks_previous    = m_ticks_latest;
   \   0000000A   0x....             LDR      R0,??DataTable25_2
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x0005             MOVS     R5,R0
    745              timer_id_head_old = m_timer_id_head;
   \   00000010   0x....             LDR      R0,??DataTable25_3
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x0006             MOVS     R6,R0
    746              
    747              // Get number of elapsed ticks
    748              ticks_have_elapsed = elapsed_ticks_acquire(&ticks_elapsed);
   \   00000016   0xA801             ADD      R0,SP,#+4
   \   00000018   0x.... 0x....      BL       elapsed_ticks_acquire
   \   0000001C   0x0007             MOVS     R7,R0
    749          
    750              // Handle list deletions
    751              compare_update = list_deletions_handler();
   \   0000001E   0x.... 0x....      BL       list_deletions_handler
   \   00000022   0x0004             MOVS     R4,R0
    752              
    753              // Handle expired timers
    754              if (ticks_have_elapsed)
   \   00000024   0xB2FF             UXTB     R7,R7
   \   00000026   0x2F00             CMP      R7,#+0
   \   00000028   0xD006             BEQ      ??timer_list_handler_0
    755              {
    756                  expired_timers_handler(ticks_elapsed, ticks_previous, &restart_list_head);
   \   0000002A   0x466A             MOV      R2,SP
   \   0000002C   0x0029             MOVS     R1,R5
   \   0000002E   0x9801             LDR      R0,[SP, #+4]
   \   00000030   0x.... 0x....      BL       expired_timers_handler
    757                  compare_update = true;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x0004             MOVS     R4,R0
    758              }
    759              
    760              // Handle list insertions
    761              if (list_insertions_handler(restart_list_head))
   \                     ??timer_list_handler_0: (+1)
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0x.... 0x....      BL       list_insertions_handler
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD001             BEQ      ??timer_list_handler_1
    762              {
    763                  compare_update = true;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x0004             MOVS     R4,R0
    764              }
    765          
    766              // Update compare register if necessary
    767              if (compare_update)
   \                     ??timer_list_handler_1: (+1)
   \   00000046   0xB2E4             UXTB     R4,R4
   \   00000048   0x2C00             CMP      R4,#+0
   \   0000004A   0xD002             BEQ      ??timer_list_handler_2
    768              {
    769                  compare_reg_update(timer_id_head_old);
   \   0000004C   0x0030             MOVS     R0,R6
   \   0000004E   0x.... 0x....      BL       compare_reg_update
    770              }
    771              m_rtc1_reset = false;
   \                     ??timer_list_handler_2: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x....             LDR      R1,??DataTable25
   \   00000056   0x7008             STRB     R0,[R1, #+0]
    772          }
   \   00000058   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    773          
    774          
    775          /**@brief Function for enqueueing a new operations queue entry.
    776           *
    777           * @param[in]  p_user     User that the entry is to be enqueued for.
    778           * @param[in]  last_index Index of the next last index to be enqueued.
    779           */

   \                                 In section .text, align 2, keep-with-next
    780          static void user_op_enque(timer_user_t * p_user, app_timer_id_t last_index)
    781          {
    782              p_user->last = last_index;
   \                     user_op_enque: (+1)
   \   00000000   0x000A             MOVS     R2,R1
   \   00000002   0x7042             STRB     R2,[R0, #+1]
    783          }
   \   00000004   0x4770             BX       LR               ;; return
    784          
    785          
    786          /**@brief Function for allocating a new operations queue entry.
    787           *
    788           * @param[in]  p_user       User that the entry is to be allocated for.
    789           * @param[out] p_last_index Index of the next last index to be enqueued.
    790           *
    791           * @return     Pointer to allocated queue entry, or NULL if queue is full.
    792           */

   \                                 In section .text, align 2, keep-with-next
    793          static timer_user_op_t * user_op_alloc(timer_user_t * p_user, app_timer_id_t * p_last_index)
    794          {        
   \                     user_op_alloc: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0002             MOVS     R2,R0
    795              app_timer_id_t    last;
    796              timer_user_op_t * p_user_op;
    797              
    798              last = p_user->last + 1;
   \   00000004   0x7850             LDRB     R0,[R2, #+1]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x0003             MOVS     R3,R0
    799              if (last == p_user->user_op_queue_size)
   \   0000000A   0x7890             LDRB     R0,[R2, #+2]
   \   0000000C   0x4283             CMP      R3,R0
   \   0000000E   0xD101             BNE      ??user_op_alloc_0
    800              {
    801                  // Overflow case.
    802                  last = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x0003             MOVS     R3,R0
    803              }
    804              if (last == p_user->first)
   \                     ??user_op_alloc_0: (+1)
   \   00000014   0x7810             LDRB     R0,[R2, #+0]
   \   00000016   0x4283             CMP      R3,R0
   \   00000018   0xD101             BNE      ??user_op_alloc_1
    805              {
    806                  // Queue is full.
    807                  return NULL;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE007             B        ??user_op_alloc_2
    808              }
    809              
    810              *p_last_index = last;    
   \                     ??user_op_alloc_1: (+1)
   \   0000001E   0x600B             STR      R3,[R1, #+0]
    811              p_user_op     = &p_user->p_user_op_queue[p_user->last];
   \   00000020   0x6850             LDR      R0,[R2, #+4]
   \   00000022   0x7855             LDRB     R5,[R2, #+1]
   \   00000024   0x2618             MOVS     R6,#+24
   \   00000026   0x4375             MULS     R5,R6,R5
   \   00000028   0x1940             ADDS     R0,R0,R5
   \   0000002A   0x0004             MOVS     R4,R0
    812                  
    813              return p_user_op;
   \   0000002C   0x0020             MOVS     R0,R4
   \                     ??user_op_alloc_2: (+1)
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return
    814          }
    815          
    816          
    817          /**@brief Function for scheduling a Timer Start operation.
    818           *
    819           * @param[in]  user_id           Id of user calling this function.
    820           * @param[in]  timer_id          Id of timer to start.
    821           * @param[in]  timeout_initial   Time (in ticks) to first timer expiry.
    822           * @param[in]  timeout_periodic  Time (in ticks) between periodic expiries.
    823           * @param[in]  p_context         General purpose pointer. Will be passed to the timeout handler when
    824           *                               the timer expires.
    825           * @return     NRF_SUCCESS on success, otherwise an error code.
    826           */

   \                                 In section .text, align 2, keep-with-next
    827          static uint32_t timer_start_op_schedule(timer_user_id_t user_id,
    828                                                  app_timer_id_t  timer_id,
    829                                                  uint32_t        timeout_initial,
    830                                                  uint32_t        timeout_periodic,
    831                                                  void *          p_context)
    832          {
   \                     timer_start_op_schedule: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x9E08             LDR      R6,[SP, #+32]
    833              app_timer_id_t last_index;
    834              
    835              timer_user_op_t * p_user_op = user_op_alloc(&mp_users[user_id], &last_index);
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x....             LDR      R0,??DataTable29
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x2208             MOVS     R2,#+8
   \   00000010   0x4362             MULS     R2,R4,R2
   \   00000012   0x1880             ADDS     R0,R0,R2
   \   00000014   0x.... 0x....      BL       user_op_alloc
   \   00000018   0x0005             MOVS     R5,R0
    836              if (p_user_op == NULL)
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD101             BNE      ??timer_start_op_schedule_0
    837              {
    838                  return NRF_ERROR_NO_MEM;
   \   0000001E   0x2004             MOVS     R0,#+4
   \   00000020   0xE015             B        ??timer_start_op_schedule_1
    839              }
    840              
    841              p_user_op->op_type                              = TIMER_USER_OP_TYPE_START;
   \                     ??timer_start_op_schedule_0: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x7028             STRB     R0,[R5, #+0]
    842              p_user_op->timer_id                             = timer_id;
   \   00000026   0x606F             STR      R7,[R5, #+4]
    843              p_user_op->params.start.ticks_at_start          = rtc1_counter_get();
   \   00000028   0x.... 0x....      BL       rtc1_counter_get
   \   0000002C   0x60A8             STR      R0,[R5, #+8]
    844              p_user_op->params.start.ticks_first_interval    = timeout_initial;
   \   0000002E   0x9801             LDR      R0,[SP, #+4]
   \   00000030   0x60E8             STR      R0,[R5, #+12]
    845              p_user_op->params.start.ticks_periodic_interval = timeout_periodic;
   \   00000032   0x9802             LDR      R0,[SP, #+8]
   \   00000034   0x6128             STR      R0,[R5, #+16]
    846              p_user_op->params.start.p_context               = p_context;
   \   00000036   0x616E             STR      R6,[R5, #+20]
    847              
    848              user_op_enque(&mp_users[user_id], last_index);    
   \   00000038   0x9900             LDR      R1,[SP, #+0]
   \   0000003A   0x....             LDR      R0,??DataTable29
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x2208             MOVS     R2,#+8
   \   00000040   0x4362             MULS     R2,R4,R2
   \   00000042   0x1880             ADDS     R0,R0,R2
   \   00000044   0x.... 0x....      BL       user_op_enque
    849          
    850              timer_list_handler_sched();
   \   00000048   0x.... 0x....      BL       timer_list_handler_sched
    851          
    852              return NRF_SUCCESS;
   \   0000004C   0x2000             MOVS     R0,#+0
   \                     ??timer_start_op_schedule_1: (+1)
   \   0000004E   0xBDFE             POP      {R1-R7,PC}       ;; return
    853          }
    854          
    855          
    856          /**@brief Function for scheduling a Timer Stop operation.
    857           *
    858           * @param[in]  user_id    Id of user calling this function.
    859           * @param[in]  timer_id   Id of timer to stop.
    860           *
    861           * @return NRF_SUCCESS on successful scheduling a timer stop operation. NRF_ERROR_NO_MEM when there
    862           *         is no memory left to schedule the timer stop operation.
    863           */

   \                                 In section .text, align 2, keep-with-next
    864          static uint32_t timer_stop_op_schedule(timer_user_id_t user_id, app_timer_id_t timer_id)
    865          {
   \                     timer_stop_op_schedule: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000E             MOVS     R6,R1
    866              app_timer_id_t last_index;
    867              
    868              timer_user_op_t * p_user_op = user_op_alloc(&mp_users[user_id], &last_index);
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x....             LDR      R0,??DataTable30
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x2208             MOVS     R2,#+8
   \   00000010   0x4362             MULS     R2,R4,R2
   \   00000012   0x1880             ADDS     R0,R0,R2
   \   00000014   0x.... 0x....      BL       user_op_alloc
   \   00000018   0x0005             MOVS     R5,R0
    869              if (p_user_op == NULL)
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD101             BNE      ??timer_stop_op_schedule_0
    870              {
    871                  return NRF_ERROR_NO_MEM;
   \   0000001E   0x2004             MOVS     R0,#+4
   \   00000020   0xE00D             B        ??timer_stop_op_schedule_1
    872              }
    873              
    874              p_user_op->op_type  = TIMER_USER_OP_TYPE_STOP;
   \                     ??timer_stop_op_schedule_0: (+1)
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0x7028             STRB     R0,[R5, #+0]
    875              p_user_op->timer_id = timer_id;
   \   00000026   0x606E             STR      R6,[R5, #+4]
    876              
    877              user_op_enque(&mp_users[user_id], last_index);        
   \   00000028   0x9900             LDR      R1,[SP, #+0]
   \   0000002A   0x....             LDR      R0,??DataTable30
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x2208             MOVS     R2,#+8
   \   00000030   0x4362             MULS     R2,R4,R2
   \   00000032   0x1880             ADDS     R0,R0,R2
   \   00000034   0x.... 0x....      BL       user_op_enque
    878          
    879              timer_list_handler_sched();
   \   00000038   0x.... 0x....      BL       timer_list_handler_sched
    880          
    881              return NRF_SUCCESS;
   \   0000003C   0x2000             MOVS     R0,#+0
   \                     ??timer_stop_op_schedule_1: (+1)
   \   0000003E   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    882          }
    883          
    884          
    885          /**@brief Function for scheduling a Timer Stop All operation.
    886           *
    887           * @param[in]  user_id    Id of user calling this function.
    888           */

   \                                 In section .text, align 2, keep-with-next
    889          static uint32_t timer_stop_all_op_schedule(timer_user_id_t user_id)
    890          {
   \                     timer_stop_all_op_schedule: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    891              app_timer_id_t last_index;
    892              
    893              timer_user_op_t * p_user_op = user_op_alloc(&mp_users[user_id], &last_index);
   \   00000004   0x4669             MOV      R1,SP
   \   00000006   0x....             LDR      R0,??DataTable30
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x2208             MOVS     R2,#+8
   \   0000000C   0x4362             MULS     R2,R4,R2
   \   0000000E   0x1880             ADDS     R0,R0,R2
   \   00000010   0x.... 0x....      BL       user_op_alloc
   \   00000014   0x0005             MOVS     R5,R0
    894              if (p_user_op == NULL)
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD101             BNE      ??timer_stop_all_op_schedule_0
    895              {
    896                  return NRF_ERROR_NO_MEM;
   \   0000001A   0x2004             MOVS     R0,#+4
   \   0000001C   0xE00F             B        ??timer_stop_all_op_schedule_1
    897              }
    898              
    899              p_user_op->op_type  = TIMER_USER_OP_TYPE_STOP_ALL;
   \                     ??timer_stop_all_op_schedule_0: (+1)
   \   0000001E   0x2003             MOVS     R0,#+3
   \   00000020   0x7028             STRB     R0,[R5, #+0]
    900              p_user_op->timer_id = TIMER_NULL;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000026   0x6068             STR      R0,[R5, #+4]
    901              
    902              user_op_enque(&mp_users[user_id], last_index);        
   \   00000028   0x9900             LDR      R1,[SP, #+0]
   \   0000002A   0x....             LDR      R0,??DataTable30
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x2208             MOVS     R2,#+8
   \   00000030   0x4362             MULS     R2,R4,R2
   \   00000032   0x1880             ADDS     R0,R0,R2
   \   00000034   0x.... 0x....      BL       user_op_enque
    903          
    904              timer_list_handler_sched();
   \   00000038   0x.... 0x....      BL       timer_list_handler_sched
    905          
    906              return NRF_SUCCESS;
   \   0000003C   0x2000             MOVS     R0,#+0
   \                     ??timer_stop_all_op_schedule_1: (+1)
   \   0000003E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    907          }
    908          
    909          
    910          /**@brief Function for handling the RTC1 interrupt.
    911           *
    912           * @details Checks for timeouts, and executes timeout handlers for expired timers.
    913           */

   \                                 In section .text, align 2, keep-with-next
    914          void RTC1_IRQHandler(void)
    915          {
   \                     RTC1_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    916              // Clear all events (also unexpected ones)
    917              NRF_RTC1->EVENTS_COMPARE[0] = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR      R1,??DataTable30_1  ;; 0x40011140
   \   00000006   0x6008             STR      R0,[R1, #+0]
    918              NRF_RTC1->EVENTS_COMPARE[1] = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x....             LDR      R1,??DataTable30_2  ;; 0x40011144
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    919              NRF_RTC1->EVENTS_COMPARE[2] = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x....             LDR      R1,??DataTable30_3  ;; 0x40011148
   \   00000012   0x6008             STR      R0,[R1, #+0]
    920              NRF_RTC1->EVENTS_COMPARE[3] = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x....             LDR      R1,??DataTable30_4  ;; 0x4001114c
   \   00000018   0x6008             STR      R0,[R1, #+0]
    921              NRF_RTC1->EVENTS_TICK       = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x....             LDR      R1,??DataTable30_5  ;; 0x40011100
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    922              NRF_RTC1->EVENTS_OVRFLW     = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x....             LDR      R1,??DataTable30_6  ;; 0x40011104
   \   00000024   0x6008             STR      R0,[R1, #+0]
    923          
    924              // Check for expired timers
    925              timer_timeouts_check();
   \   00000026   0x.... 0x....      BL       timer_timeouts_check
    926          }
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return
    927          
    928          
    929          /**@brief Function for handling the SWI0 interrupt.
    930           *
    931           * @details Performs all updates to the timer list.
    932           */

   \                                 In section .text, align 2, keep-with-next
    933          void SWI0_IRQHandler(void)
    934          {
   \                     SWI0_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    935              timer_list_handler();
   \   00000002   0x.... 0x....      BL       timer_list_handler
    936          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    937          
    938          

   \                                 In section .text, align 2, keep-with-next
    939          uint32_t app_timer_init(uint32_t                      prescaler,
    940                                  uint8_t                       max_timers,
    941                                  uint8_t                       op_queues_size,
    942                                  void *                        p_buffer,
    943                                  app_timer_evt_schedule_func_t evt_schedule_func)
    944          {
   \                     app_timer_init: (+1)
   \   00000000   0xB5F5             PUSH     {R0,R2,R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x001C             MOVS     R4,R3
   \   00000008   0x9F08             LDR      R7,[SP, #+32]
    945              int i;
    946          
    947              // Check that buffer is correctly aligned
    948              if (!is_word_aligned(p_buffer))
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       is_word_aligned
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD101             BNE      ??app_timer_init_0
    949              {
    950                  return NRF_ERROR_INVALID_PARAM;
   \   00000014   0x2007             MOVS     R0,#+7
   \   00000016   0xE05D             B        ??app_timer_init_1
    951              }
    952              // Check for NULL buffer
    953              if (p_buffer == NULL)
   \                     ??app_timer_init_0: (+1)
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD101             BNE      ??app_timer_init_2
    954              {
    955                  return NRF_ERROR_INVALID_PARAM;
   \   0000001C   0x2007             MOVS     R0,#+7
   \   0000001E   0xE059             B        ??app_timer_init_1
    956              }
    957              
    958              // Stop RTC to prevent any running timers from expiring (in case of reinitialization)
    959              rtc1_stop();
   \                     ??app_timer_init_2: (+1)
   \   00000020   0x.... 0x....      BL       rtc1_stop
    960              
    961              m_evt_schedule_func = evt_schedule_func;
   \   00000024   0x....             LDR      R0,??DataTable30_7
   \   00000026   0x6007             STR      R7,[R0, #+0]
    962          
    963              // Initialize timer node array
    964              m_node_array_size = max_timers;
   \   00000028   0x....             LDR      R0,??DataTable30_8
   \   0000002A   0x7006             STRB     R6,[R0, #+0]
    965              mp_nodes          = p_buffer;
   \   0000002C   0x....             LDR      R0,??DataTable30_9
   \   0000002E   0x6004             STR      R4,[R0, #+0]
    966              
    967              for (i = 0; i < max_timers; i++)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x0005             MOVS     R5,R0
   \                     ??app_timer_init_3: (+1)
   \   00000034   0xB2F6             UXTB     R6,R6
   \   00000036   0x42B5             CMP      R5,R6
   \   00000038   0xDA0E             BGE      ??app_timer_init_4
    968              {
    969                  mp_nodes[i].state      = STATE_FREE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x....             LDR      R1,??DataTable30_9
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0x2224             MOVS     R2,#+36
   \   00000042   0x436A             MULS     R2,R5,R2
   \   00000044   0x5488             STRB     R0,[R1, R2]
    970                  mp_nodes[i].is_running = false;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x....             LDR      R1,??DataTable30_9
   \   0000004A   0x6809             LDR      R1,[R1, #+0]
   \   0000004C   0x2224             MOVS     R2,#+36
   \   0000004E   0x436A             MULS     R2,R5,R2
   \   00000050   0x1889             ADDS     R1,R1,R2
   \   00000052   0x7508             STRB     R0,[R1, #+20]
    971              }
   \   00000054   0x1C6D             ADDS     R5,R5,#+1
   \   00000056   0xE7ED             B        ??app_timer_init_3
    972              
    973              // Skip timer node array
    974              p_buffer = &((uint8_t *)p_buffer)[max_timers * sizeof(timer_node_t)];
   \                     ??app_timer_init_4: (+1)
   \   00000058   0xB2F6             UXTB     R6,R6
   \   0000005A   0x2024             MOVS     R0,#+36
   \   0000005C   0x4370             MULS     R0,R6,R0
   \   0000005E   0x1824             ADDS     R4,R4,R0
    975              
    976              // Initialize users array
    977              m_user_array_size = APP_TIMER_INT_LEVELS;
   \   00000060   0x2003             MOVS     R0,#+3
   \   00000062   0x....             LDR      R1,??DataTable30_10
   \   00000064   0x7008             STRB     R0,[R1, #+0]
    978              mp_users          = p_buffer;
   \   00000066   0x....             LDR      R0,??DataTable29
   \   00000068   0x6004             STR      R4,[R0, #+0]
    979              
    980              // Skip user array
    981              p_buffer = &((uint8_t *)p_buffer)[APP_TIMER_INT_LEVELS * sizeof(timer_user_t)];
   \   0000006A   0x3418             ADDS     R4,R4,#+24
    982          
    983              // Initialize operation queues
    984              for (i = 0; i < APP_TIMER_INT_LEVELS; i++)
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x0005             MOVS     R5,R0
   \                     ??app_timer_init_5: (+1)
   \   00000070   0x2D03             CMP      R5,#+3
   \   00000072   0xDA13             BGE      ??app_timer_init_6
    985              {
    986                  timer_user_t * p_user = &mp_users[i];
   \   00000074   0x....             LDR      R0,??DataTable29
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x2108             MOVS     R1,#+8
   \   0000007A   0x4369             MULS     R1,R5,R1
   \   0000007C   0x1840             ADDS     R0,R0,R1
    987                  
    988                  p_user->first              = 0;
   \   0000007E   0x2100             MOVS     R1,#+0
   \   00000080   0x7001             STRB     R1,[R0, #+0]
    989                  p_user->last               = 0;
   \   00000082   0x2100             MOVS     R1,#+0
   \   00000084   0x7041             STRB     R1,[R0, #+1]
    990                  p_user->user_op_queue_size = op_queues_size;
   \   00000086   0x4669             MOV      R1,SP
   \   00000088   0x7A09             LDRB     R1,[R1, #+8]
   \   0000008A   0x7081             STRB     R1,[R0, #+2]
    991                  p_user->p_user_op_queue    = p_buffer;
   \   0000008C   0x6044             STR      R4,[R0, #+4]
    992              
    993                  // Skip operation queue
    994                  p_buffer = &((uint8_t *)p_buffer)[op_queues_size * sizeof(timer_user_op_t)];
   \   0000008E   0x4669             MOV      R1,SP
   \   00000090   0x7A09             LDRB     R1,[R1, #+8]
   \   00000092   0x2218             MOVS     R2,#+24
   \   00000094   0x4351             MULS     R1,R2,R1
   \   00000096   0x1864             ADDS     R4,R4,R1
    995              }
   \   00000098   0x1C6D             ADDS     R5,R5,#+1
   \   0000009A   0xE7E9             B        ??app_timer_init_5
    996          
    997              m_timer_id_head             = TIMER_NULL;
   \                     ??app_timer_init_6: (+1)
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x43C0             MVNS     R0,R0            ;; #-1
   \   000000A0   0x....             LDR      R1,??DataTable30_11
   \   000000A2   0x6008             STR      R0,[R1, #+0]
    998              m_ticks_elapsed_q_read_ind  = 0;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x....             LDR      R1,??DataTable30_12
   \   000000A8   0x7008             STRB     R0,[R1, #+0]
    999              m_ticks_elapsed_q_write_ind = 0;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x....             LDR      R1,??DataTable30_13
   \   000000AE   0x7008             STRB     R0,[R1, #+0]
   1000          
   1001              NVIC_ClearPendingIRQ(SWI0_IRQn);
   \   000000B0   0x2014             MOVS     R0,#+20
   \   000000B2   0x.... 0x....      BL       NVIC_ClearPendingIRQ
   1002              NVIC_SetPriority(SWI0_IRQn, SWI0_IRQ_PRI);
   \   000000B6   0x2103             MOVS     R1,#+3
   \   000000B8   0x2014             MOVS     R0,#+20
   \   000000BA   0x.... 0x....      BL       NVIC_SetPriority
   1003              NVIC_EnableIRQ(SWI0_IRQn);
   \   000000BE   0x2014             MOVS     R0,#+20
   \   000000C0   0x.... 0x....      BL       NVIC_EnableIRQ
   1004          
   1005              rtc1_init(prescaler);
   \   000000C4   0x9801             LDR      R0,[SP, #+4]
   \   000000C6   0x.... 0x....      BL       rtc1_init
   1006          
   1007              m_ticks_latest = rtc1_counter_get();
   \   000000CA   0x.... 0x....      BL       rtc1_counter_get
   \   000000CE   0x....             LDR      R1,??DataTable30_14
   \   000000D0   0x6008             STR      R0,[R1, #+0]
   1008              
   1009              return NRF_SUCCESS;
   \   000000D2   0x2000             MOVS     R0,#+0
   \                     ??app_timer_init_1: (+1)
   \   000000D4   0xBDFE             POP      {R1-R7,PC}       ;; return
   1010          }
   1011          
   1012          

   \                                 In section .text, align 2, keep-with-next
   1013          uint32_t app_timer_create(app_timer_id_t *            p_timer_id,
   1014                                    app_timer_mode_t            mode,
   1015                                    app_timer_timeout_handler_t timeout_handler)
   1016          {
   \                     app_timer_create: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0003             MOVS     R3,R0
   1017              int i;
   1018          
   1019              // Check state and parameters
   1020              if (mp_nodes == NULL)
   \   00000004   0x....             LDR      R0,??DataTable30_9
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD101             BNE      ??app_timer_create_0
   1021              {
   1022                  return NRF_ERROR_INVALID_STATE;
   \   0000000C   0x2008             MOVS     R0,#+8
   \   0000000E   0xE02D             B        ??app_timer_create_1
   1023              }
   1024              if (timeout_handler == NULL)
   \                     ??app_timer_create_0: (+1)
   \   00000010   0x0010             MOVS     R0,R2
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD101             BNE      ??app_timer_create_2
   1025              {
   1026                  return NRF_ERROR_INVALID_PARAM;
   \   00000016   0x2007             MOVS     R0,#+7
   \   00000018   0xE028             B        ??app_timer_create_1
   1027              }
   1028              if (p_timer_id == NULL)
   \                     ??app_timer_create_2: (+1)
   \   0000001A   0x2B00             CMP      R3,#+0
   \   0000001C   0xD101             BNE      ??app_timer_create_3
   1029              {
   1030                  return NRF_ERROR_INVALID_PARAM;
   \   0000001E   0x2007             MOVS     R0,#+7
   \   00000020   0xE024             B        ??app_timer_create_1
   1031              }    
   1032              
   1033              // Find free timer
   1034              for (i = 0; i < m_node_array_size; i++)
   \                     ??app_timer_create_3: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x0004             MOVS     R4,R0
   \                     ??app_timer_create_4: (+1)
   \   00000026   0x....             LDR      R0,??DataTable30_8
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xDA1D             BGE      ??app_timer_create_5
   1035              {
   1036                  if (mp_nodes[i].state == STATE_FREE)
   \   0000002E   0x....             LDR      R0,??DataTable30_9
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x2524             MOVS     R5,#+36
   \   00000034   0x4365             MULS     R5,R4,R5
   \   00000036   0x5D40             LDRB     R0,[R0, R5]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD114             BNE      ??app_timer_create_6
   1037                  {
   1038                      mp_nodes[i].state             = STATE_ALLOCATED;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x....             LDR      R5,??DataTable30_9
   \   00000040   0x682D             LDR      R5,[R5, #+0]
   \   00000042   0x2624             MOVS     R6,#+36
   \   00000044   0x4366             MULS     R6,R4,R6
   \   00000046   0x55A8             STRB     R0,[R5, R6]
   1039                      mp_nodes[i].mode              = mode;
   \   00000048   0x....             LDR      R0,??DataTable30_9
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x2524             MOVS     R5,#+36
   \   0000004E   0x4365             MULS     R5,R4,R5
   \   00000050   0x1940             ADDS     R0,R0,R5
   \   00000052   0x7041             STRB     R1,[R0, #+1]
   1040                      mp_nodes[i].p_timeout_handler = timeout_handler;
   \   00000054   0x....             LDR      R0,??DataTable30_9
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x2524             MOVS     R5,#+36
   \   0000005A   0x4365             MULS     R5,R4,R5
   \   0000005C   0x1940             ADDS     R0,R0,R5
   \   0000005E   0x6182             STR      R2,[R0, #+24]
   1041                      
   1042                      *p_timer_id = i;
   \   00000060   0x601C             STR      R4,[R3, #+0]
   1043                      return NRF_SUCCESS;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xE002             B        ??app_timer_create_1
   1044                  }
   1045              }
   \                     ??app_timer_create_6: (+1)
   \   00000066   0x1C64             ADDS     R4,R4,#+1
   \   00000068   0xE7DD             B        ??app_timer_create_4
   1046              
   1047              return NRF_ERROR_NO_MEM;
   \                     ??app_timer_create_5: (+1)
   \   0000006A   0x2004             MOVS     R0,#+4
   \                     ??app_timer_create_1: (+1)
   \   0000006C   0xBD70             POP      {R4-R6,PC}       ;; return
   1048          }
   1049          
   1050          
   1051          /**@brief Function for creating a timer user id from the current interrupt level.
   1052           *
   1053           * @return     Timer user id.
   1054          */

   \                                 In section .text, align 2, keep-with-next
   1055          static timer_user_id_t user_id_get(void)
   1056          {
   \                     user_id_get: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1057              timer_user_id_t ret;
   1058          
   1059              STATIC_ASSERT(APP_TIMER_INT_LEVELS == 3);
   1060              
   1061              switch (current_int_priority_get())
   \   00000002   0x.... 0x....      BL       current_int_priority_get
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD002             BEQ      ??user_id_get_0
   \   0000000A   0x2803             CMP      R0,#+3
   \   0000000C   0xD003             BEQ      ??user_id_get_1
   \   0000000E   0xE005             B        ??user_id_get_2
   1062              {
   1063                  case APP_IRQ_PRIORITY_HIGH:
   1064                      ret = APP_HIGH_USER_ID;
   \                     ??user_id_get_0: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x0004             MOVS     R4,R0
   1065                      break;
   \   00000014   0xE004             B        ??user_id_get_3
   1066                      
   1067                  case APP_IRQ_PRIORITY_LOW:
   1068                      ret = APP_LOW_USER_ID;
   \                     ??user_id_get_1: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x0004             MOVS     R4,R0
   1069                      break;
   \   0000001A   0xE001             B        ??user_id_get_3
   1070                      
   1071                  default:
   1072                      ret = THREAD_MODE_USER_ID;
   \                     ??user_id_get_2: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x0004             MOVS     R4,R0
   1073                      break;
   1074              }
   1075              
   1076              return ret;
   \                     ??user_id_get_3: (+1)
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
   1077          }
   1078          
   1079          

   \                                 In section .text, align 2, keep-with-next
   1080          uint32_t app_timer_start(app_timer_id_t timer_id, uint32_t timeout_ticks, void * p_context)
   1081          {
   \                     app_timer_start: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0017             MOVS     R7,R2
   1082              uint32_t timeout_periodic;
   1083              
   1084              // Check state and parameters
   1085              if (mp_nodes == NULL)
   \   00000008   0x....             LDR      R0,??DataTable30_9
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD101             BNE      ??app_timer_start_0
   1086              {
   1087                  return NRF_ERROR_INVALID_STATE;
   \   00000010   0x2008             MOVS     R0,#+8
   \   00000012   0xE023             B        ??app_timer_start_1
   1088              }
   1089              if ((timer_id >= m_node_array_size) || (timeout_ticks < APP_TIMER_MIN_TIMEOUT_TICKS))
   \                     ??app_timer_start_0: (+1)
   \   00000014   0x....             LDR      R0,??DataTable30_8
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD201             BCS      ??app_timer_start_2
   \   0000001C   0x2E05             CMP      R6,#+5
   \   0000001E   0xD201             BCS      ??app_timer_start_3
   1090              {
   1091                  return NRF_ERROR_INVALID_PARAM;
   \                     ??app_timer_start_2: (+1)
   \   00000020   0x2007             MOVS     R0,#+7
   \   00000022   0xE01B             B        ??app_timer_start_1
   1092              }
   1093              if (mp_nodes[timer_id].state != STATE_ALLOCATED)
   \                     ??app_timer_start_3: (+1)
   \   00000024   0x....             LDR      R0,??DataTable30_9
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x2124             MOVS     R1,#+36
   \   0000002A   0x4361             MULS     R1,R4,R1
   \   0000002C   0x5C40             LDRB     R0,[R0, R1]
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD001             BEQ      ??app_timer_start_4
   1094              {
   1095                  return NRF_ERROR_INVALID_STATE;
   \   00000032   0x2008             MOVS     R0,#+8
   \   00000034   0xE012             B        ??app_timer_start_1
   1096              }
   1097              
   1098              // Schedule timer start operation
   1099              timeout_periodic = (mp_nodes[timer_id].mode == APP_TIMER_MODE_REPEATED) ? timeout_ticks : 0;
   \                     ??app_timer_start_4: (+1)
   \   00000036   0x....             LDR      R0,??DataTable30_9
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x2124             MOVS     R1,#+36
   \   0000003C   0x4361             MULS     R1,R4,R1
   \   0000003E   0x1840             ADDS     R0,R0,R1
   \   00000040   0x7840             LDRB     R0,[R0, #+1]
   \   00000042   0x2801             CMP      R0,#+1
   \   00000044   0xD101             BNE      ??app_timer_start_5
   \   00000046   0x0035             MOVS     R5,R6
   \   00000048   0xE000             B        ??app_timer_start_6
   \                     ??app_timer_start_5: (+1)
   \   0000004A   0x2500             MOVS     R5,#+0
   1100          
   1101              return timer_start_op_schedule(user_id_get(),
   1102                                             timer_id,
   1103                                             timeout_ticks,
   1104                                             timeout_periodic,
   1105                                             p_context);
   \                     ??app_timer_start_6: (+1)
   \   0000004C   0x.... 0x....      BL       user_id_get
   \   00000050   0x9700             STR      R7,[SP, #+0]
   \   00000052   0x002B             MOVS     R3,R5
   \   00000054   0x0032             MOVS     R2,R6
   \   00000056   0x0021             MOVS     R1,R4
   \   00000058   0x.... 0x....      BL       timer_start_op_schedule
   \                     ??app_timer_start_1: (+1)
   \   0000005C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1106          }
   1107          
   1108          

   \                                 In section .text, align 2, keep-with-next
   1109          uint32_t app_timer_stop(app_timer_id_t timer_id)
   1110          {
   \                     app_timer_stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1111              // Check state and parameters
   1112              if (mp_nodes == NULL)
   \   00000004   0x....             LDR      R0,??DataTable30_9
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD101             BNE      ??app_timer_stop_0
   1113              {
   1114                  return NRF_ERROR_INVALID_STATE;
   \   0000000C   0x2008             MOVS     R0,#+8
   \   0000000E   0xE013             B        ??app_timer_stop_1
   1115              }
   1116              if (timer_id >= m_node_array_size)
   \                     ??app_timer_stop_0: (+1)
   \   00000010   0x....             LDR      R0,??DataTable30_8
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD301             BCC      ??app_timer_stop_2
   1117              {
   1118                  return NRF_ERROR_INVALID_PARAM;
   \   00000018   0x2007             MOVS     R0,#+7
   \   0000001A   0xE00D             B        ??app_timer_stop_1
   1119              }
   1120              if (mp_nodes[timer_id].state != STATE_ALLOCATED)
   \                     ??app_timer_stop_2: (+1)
   \   0000001C   0x....             LDR      R0,??DataTable30_9
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x2124             MOVS     R1,#+36
   \   00000022   0x4361             MULS     R1,R4,R1
   \   00000024   0x5C40             LDRB     R0,[R0, R1]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD001             BEQ      ??app_timer_stop_3
   1121              {
   1122                  return NRF_ERROR_INVALID_STATE;
   \   0000002A   0x2008             MOVS     R0,#+8
   \   0000002C   0xE004             B        ??app_timer_stop_1
   1123              }
   1124              
   1125              // Schedule timer stop operation
   1126              return timer_stop_op_schedule(user_id_get(), timer_id);
   \                     ??app_timer_stop_3: (+1)
   \   0000002E   0x.... 0x....      BL       user_id_get
   \   00000032   0x0021             MOVS     R1,R4
   \   00000034   0x.... 0x....      BL       timer_stop_op_schedule
   \                     ??app_timer_stop_1: (+1)
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
   1127          }
   1128          
   1129          

   \                                 In section .text, align 2, keep-with-next
   1130          uint32_t app_timer_stop_all(void)
   1131          {
   \                     app_timer_stop_all: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1132              // Check state
   1133              if (mp_nodes == NULL)
   \   00000002   0x....             LDR      R0,??DataTable30_9
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD101             BNE      ??app_timer_stop_all_0
   1134              {
   1135                  return NRF_ERROR_INVALID_STATE;
   \   0000000A   0x2008             MOVS     R0,#+8
   \   0000000C   0xE003             B        ??app_timer_stop_all_1
   1136              }
   1137          
   1138              return timer_stop_all_op_schedule(user_id_get());
   \                     ??app_timer_stop_all_0: (+1)
   \   0000000E   0x.... 0x....      BL       user_id_get
   \   00000012   0x.... 0x....      BL       timer_stop_all_op_schedule
   \                     ??app_timer_stop_all_1: (+1)
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
   1139          }
   1140          
   1141          

   \                                 In section .text, align 2, keep-with-next
   1142          uint32_t app_timer_cnt_get(uint32_t * p_ticks)
   1143          {
   \                     app_timer_cnt_get: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1144              *p_ticks = rtc1_counter_get();
   \   00000004   0x.... 0x....      BL       rtc1_counter_get
   \   00000008   0x6020             STR      R0,[R4, #+0]
   1145              return NRF_SUCCESS;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
   1146          }
   1147          
   1148          

   \                                 In section .text, align 2, keep-with-next
   1149          uint32_t app_timer_cnt_diff_compute(uint32_t   ticks_to,
   1150                                              uint32_t   ticks_from,
   1151                                              uint32_t * p_ticks_diff)
   1152          {
   \                     app_timer_cnt_diff_compute: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0015             MOVS     R5,R2
   1153              *p_ticks_diff = ticks_diff_get(ticks_to, ticks_from);
   \   00000008   0x0031             MOVS     R1,R6
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       ticks_diff_get
   \   00000010   0x6028             STR      R0,[R5, #+0]
   1154              return NRF_SUCCESS;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD70             POP      {R4-R6,PC}       ;; return
   1155          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0xE000E200         DC32     0xe000e200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0xE000ED1C         DC32     0xe000ed1c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0xE000E400         DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0xE000ED04         DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x40011344         DC32     0x40011344

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x40011304         DC32     0x40011304

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x40011508         DC32     0x40011508

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x........         DC32     m_rtc1_running

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x40011348         DC32     0x40011348

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x40011308         DC32     0x40011308

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x40011004         DC32     0x40011004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0x40011008         DC32     0x40011008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0x........         DC32     m_ticks_latest

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x40011504         DC32     0x40011504

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x40011540         DC32     0x40011540

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x........         DC32     mp_nodes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x........         DC32     m_timer_id_head

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x........         DC32     m_rtc1_reset

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     m_evt_schedule_func

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x........         DC32     m_ticks_elapsed_q_read_ind

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0x........         DC32     mp_nodes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     m_ticks_elapsed_q_write_ind

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x........         DC32     m_ticks_elapsed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     m_ticks_latest

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x........         DC32     m_timer_id_head

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x........         DC32     m_user_array_size

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x........         DC32     mp_users

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x........         DC32     mp_nodes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x........         DC32     m_rtc1_reset

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \   00000000   0x007FFFFF         DC32     0x7fffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_2:
   \   00000000   0x........         DC32     m_ticks_latest

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_3:
   \   00000000   0x........         DC32     m_timer_id_head

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x........         DC32     m_rtc1_running

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   0x........         DC32     mp_users

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x........         DC32     mp_users

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_1:
   \   00000000   0x40011140         DC32     0x40011140

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_2:
   \   00000000   0x40011144         DC32     0x40011144

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_3:
   \   00000000   0x40011148         DC32     0x40011148

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_4:
   \   00000000   0x4001114C         DC32     0x4001114c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_5:
   \   00000000   0x40011100         DC32     0x40011100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_6:
   \   00000000   0x40011104         DC32     0x40011104

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_7:
   \   00000000   0x........         DC32     m_evt_schedule_func

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_8:
   \   00000000   0x........         DC32     m_node_array_size

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_9:
   \   00000000   0x........         DC32     mp_nodes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_10:
   \   00000000   0x........         DC32     m_user_array_size

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_11:
   \   00000000   0x........         DC32     m_timer_id_head

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_12:
   \   00000000   0x........         DC32     m_ticks_elapsed_q_read_ind

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_13:
   \   00000000   0x........         DC32     m_ticks_elapsed_q_write_ind

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_14:
   \   00000000   0x........         DC32     m_ticks_latest
   1156          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   NVIC_ClearPendingIRQ
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ
       4   NVIC_GetPriority
       0   NVIC_SetPendingIRQ
      20   NVIC_SetPriority
       8   RTC1_IRQHandler
         8   -> timer_timeouts_check
       8   SWI0_IRQHandler
         8   -> timer_list_handler
      16   app_timer_cnt_diff_compute
        16   -> ticks_diff_get
       8   app_timer_cnt_get
         8   -> rtc1_counter_get
      16   app_timer_create
      32   app_timer_init
        32   -> NVIC_ClearPendingIRQ
        32   -> NVIC_EnableIRQ
        32   -> NVIC_SetPriority
        32   -> is_word_aligned
        32   -> rtc1_counter_get
        32   -> rtc1_init
        32   -> rtc1_stop
      24   app_timer_start
        24   -> timer_start_op_schedule
        24   -> user_id_get
       8   app_timer_stop
         8   -> timer_stop_op_schedule
         8   -> user_id_get
       8   app_timer_stop_all
         8   -> timer_stop_all_op_schedule
         8   -> user_id_get
      32   compare_reg_update
        32   -> rtc1_compare0_set
        32   -> rtc1_counter_get
        32   -> rtc1_start
        32   -> rtc1_stop
        32   -> ticks_diff_get
        32   -> timer_timeouts_check_sched
      16   current_int_priority_get
        16   -> NVIC_GetPriority
       4   elapsed_ticks_acquire
      20   expired_timers_handler
       4   is_word_aligned
      32   list_deletions_handler
        32   -> timer_list_remove
      32   list_insertions_handler
        32   -> ticks_diff_get
        32   -> timer_list_insert
       4   nrf_delay_us
       0   rtc1_compare0_set
       0   rtc1_counter_get
       8   rtc1_init
         8   -> NVIC_SetPriority
       8   rtc1_start
         8   -> NVIC_ClearPendingIRQ
         8   -> NVIC_EnableIRQ
         8   -> nrf_delay_us
       8   rtc1_stop
         8   -> NVIC_DisableIRQ
         8   -> nrf_delay_us
       0   ticks_diff_get
      16   timeout_handler_exec
        16   -- Indirect call
        16   -> app_error_handler
      32   timer_list_handler
        32   -> compare_reg_update
        32   -> elapsed_ticks_acquire
        32   -> expired_timers_handler
        32   -> list_deletions_handler
        32   -> list_insertions_handler
       8   timer_list_handler_sched
         8   -> NVIC_SetPendingIRQ
      20   timer_list_insert
      16   timer_list_remove
      32   timer_start_op_schedule
        32   -> rtc1_counter_get
        32   -> timer_list_handler_sched
        32   -> user_op_alloc
        32   -> user_op_enque
      16   timer_stop_all_op_schedule
        16   -> timer_list_handler_sched
        16   -> user_op_alloc
        16   -> user_op_enque
      24   timer_stop_op_schedule
        24   -> timer_list_handler_sched
        24   -> user_op_alloc
        24   -> user_op_enque
      24   timer_timeouts_check
        24   -> rtc1_counter_get
        24   -> ticks_diff_get
        24   -> timeout_handler_exec
        24   -> timer_list_handler_sched
       8   timer_timeouts_check_sched
         8   -> NVIC_SetPendingIRQ
       8   user_id_get
         8   -> current_int_priority_get
      16   user_op_alloc
       0   user_op_enque


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable13
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable24
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_2
       4  ??DataTable25_3
       4  ??DataTable26
       4  ??DataTable29
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable30_10
       4  ??DataTable30_11
       4  ??DataTable30_12
       4  ??DataTable30_13
       4  ??DataTable30_14
       4  ??DataTable30_2
       4  ??DataTable30_3
       4  ??DataTable30_4
       4  ??DataTable30_5
       4  ??DataTable30_6
       4  ??DataTable30_7
       4  ??DataTable30_8
       4  ??DataTable30_9
      14  NVIC_ClearPendingIRQ
      14  NVIC_DisableIRQ
      14  NVIC_EnableIRQ
      80  NVIC_GetPriority
      14  NVIC_SetPendingIRQ
     138  NVIC_SetPriority
      44  RTC1_IRQHandler
       8  SWI0_IRQHandler
      22  app_timer_cnt_diff_compute
      14  app_timer_cnt_get
     110  app_timer_create
     214  app_timer_init
      94  app_timer_start
      58  app_timer_stop
      24  app_timer_stop_all
     134  compare_reg_update
      34  current_int_priority_get
      90  elapsed_ticks_acquire
     106  expired_timers_handler
      16  is_word_aligned
     182  list_deletions_handler
     288  list_insertions_handler
       4  m_evt_schedule_func
       1  m_node_array_size
       1  m_rtc1_reset
       1  m_rtc1_running
       8  m_ticks_elapsed
       1  m_ticks_elapsed_q_read_ind
       1  m_ticks_elapsed_q_write_ind
       4  m_ticks_latest
       4  m_timer_id_head
       1  m_user_array_size
       4  mp_nodes
       4  mp_users
      34  nrf_delay_us
       6  rtc1_compare0_set
       6  rtc1_counter_get
      18  rtc1_init
      50  rtc1_start
      62  rtc1_stop
       8  ticks_diff_get
      50  timeout_handler_exec
      90  timer_list_handler
      10  timer_list_handler_sched
     222  timer_list_insert
     188  timer_list_remove
      80  timer_start_op_schedule
      64  timer_stop_all_op_schedule
      64  timer_stop_op_schedule
     138  timer_timeouts_check
      10  timer_timeouts_check_sched
      36  user_id_get
      48  user_op_alloc
       6  user_op_enque

 
    34 bytes in section .bss
 3 114 bytes in section .text
 
 3 114 bytes of CODE memory
    34 bytes of DATA memory

Errors: none
Warnings: none
